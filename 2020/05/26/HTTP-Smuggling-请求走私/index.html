<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>HTTP_Smuggling-请求走私 | xiaoZ's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.1.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HTTP_Smuggling-请求走私</h1><a id="logo" href="/.">xiaoZ's Blog</a><p class="description">Try My Best</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HTTP_Smuggling-请求走私</h1><div class="post-meta">May 26, 2020<span> | </span><span class="category"><a href="/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/">Web漏洞介绍</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2020/05/26/HTTP-Smuggling-请求走私/" href="/2020/05/26/HTTP-Smuggling-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前置知识"><span class="toc-number">1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">1.1.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keep-alive"><span class="toc-number">1.1.1.</span> <span class="toc-text">Keep alive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipline"><span class="toc-number">1.1.2.</span> <span class="toc-text">Pipline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Content-Length"><span class="toc-number">1.1.3.</span> <span class="toc-text">Content-Length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transfer-Encoding"><span class="toc-number">1.1.4.</span> <span class="toc-text">Transfer-Encoding</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反向代理"><span class="toc-number">1.2.</span> <span class="toc-text">反向代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-number">1.3.</span> <span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-Smuggling-原因"><span class="toc-number">1.4.</span> <span class="toc-text">HTTP Smuggling 原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原因分类"><span class="toc-number">2.</span> <span class="toc-text">原因分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CL不为0的GET请求"><span class="toc-number">2.1.</span> <span class="toc-text">CL不为0的GET请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-CL"><span class="toc-number">2.2.</span> <span class="toc-text">CL-CL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-TE"><span class="toc-number">2.3.</span> <span class="toc-text">CL-TE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-CL"><span class="toc-number">2.4.</span> <span class="toc-text">TE-CL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-TE"><span class="toc-number">2.5.</span> <span class="toc-text">TE-TE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用与防御"><span class="toc-number">3.</span> <span class="toc-text">利用与防御</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">5.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="post-content"><p>前几天打的<code>defcon ctf qual</code>里有一题<code>uploooadit</code>，里面涉及到<code>HTTP Smuggling | HTTP Desync Attacks</code>,也就是<code>HTTP走私攻击</code>，是一个很有趣的攻击方式了，而这个其实也和自己正在弄的协议一致性研究有所关联，于是参考了些论文和一些师傅的博客，回顾一下，并做个记录。</p>
<h2 id="前置知识">前置知识</h2>
<h3 id="HTTP-1-1">HTTP/1.1</h3>
<h4 id="Keep-alive">Keep alive</h4>
<p><code>HTTP</code>持久连接（<code>HTTP persistent connection</code>，也称作 <code>HTTP keep-alive</code> 或 <code>HTTP connection reuse</code>，翻译过来可以是保持连接或者连接复用）是使用同一个 <code>TCP</code> 连接来发送和接收多个 <code>HTTP</code> 请求应答，而不是为每一个新的请求应答打开新的连接的方式。</p>
<p><code>HTTP</code>协议采用<code>请求 - 应答</code>模式，当使用普通模式，即非<code>KeepAlive</code> 模式时，每个请求应答客户和服务器都要新建一个连接，完成 之后立即断开连接（<code>HTTP</code> 协议为无连接的协议），每次请求都会经过三次握手四次挥手过程，效率较低；当使用<code>Keep-Alive</code>模式时，客户端到服务器端的连接不会断开，当出现对服务器的后继请求时，客户端就会复用已建立的连接。</p>
<p><img src="/image/202005_smuggling/1.png" alt=""></p>
<p><code>Http1.1</code> 以后，<code>Keep-Alive</code>已经默认支持并开启。客户端（包括但不限于浏览器）发送请求时会在 <code>Header</code> 中增加一个请求头<code>Connection: Keep-Alive</code>，当服务器收到附带有<code>Connection: Keep-Alive</code>的请求时，也会在响应头中添加 <code>Keep-Alive</code>。这样一来，客户端和服务器之间的 <code>HTTP</code> 连接就会被保持，不会断开，当客户端发送另外一个请求时，就可以复用已建立的连接。</p>
<h4 id="Pipline">Pipline</h4>
<p><code>HTTP Pipine(管线化)</code>是将多个<code>HTTP</code>请求批量提交的技术，并且在发送的过程中不需要等待服务器的回应，而服务器接收后，会按照先进先出的方式将响应报文与请求报文严格对应。</p>
<p><code>pipline</code>需通过上述所说的<code>keep alive</code>模式来完成。这个模式仅<code>HTTP/1.1</code>支持（<code>HTTP/1.0</code>不支持），并且只有GET和HEAD要求可以进行管线化，而POST则有所限制。目前多数浏览器默认不启用该模式，但是服务器一般是支持的。</p>
<p>在使用<code>pipline</code>后的请求模式如下图所示：</p>
<p><img src="/image/202005_smuggling/2.png" alt=""></p>
<p>但是这里有一个问题需要讨论，在使用<code>pipline</code>时，如果服务器端对于多个请求的理解出现问题，是否可能会出现将前一个请求的内容解析为后一个请求的情况？后续会展开讨论，这个也是引发<code>HTTP Smuggling</code>的主要原因。</p>
<h4 id="Content-Length">Content-Length</h4>
<p><code>Content-Length</code>, 用于描述<code>HTTP</code>消息实体的传输长度(<code>the transfer-length of the message-body</code>), 用十进制数字表示的八位字节的数目,这里需要注意消息实体传输长度与实际消息实体长度的区别：</p>
<ul>
<li>消息实体长度：即<code>Entity-length</code>，压缩之前的<code>message-body</code>的长度</li>
<li>消息实体的传输长度：<code>Content-length</code>，压缩后的<code>message-body</code>的长度。</li>
</ul>
<p><code>Content-Length</code>表示实体内容传输长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。但是如果消息中没有<code>Conent-Length</code>，那该如何来判断？客户端如何来判断数据是否接收完成呢？</p>
<ul>
<li>
<p>静态页面或者图片：当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过<code>Content-length</code>消息首部字段告诉客户端 需要接收多少数据。</p>
</li>
<li>
<p>动态页面： 如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用<code>Transfer-Encoding：chunk</code>模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用<code>Transfer-Encoding: chunked</code>这样的方式来代替<code>Content-Length</code>。</p>
</li>
</ul>
<p>这里问题又来了，这两种方式都可以判断数据是否接收完成，我们知道很多<code>Web</code>服务是包含前置、后端服务器的（比如代理服务器），如果<code>用户-前置服务器</code>和<code>前置服务器-后端</code>的处理方式不同，是否会引发什么问题？</p>
<h4 id="Transfer-Encoding">Transfer-Encoding</h4>
<p>分块传输编码<code>(Chunked transfer encoding)</code>是<code>HTTP</code>中的一种数据传输机制，允许<code>HTTP</code>由网页服务器发送给客户端的数据可以分成多个部分。分块传输编码只在<code>HTTP/1.1</code>中提供。</p>
<p>通常，<code>HTTP Response</code>中发送的数据是整个发送的，<code>Content-Length</code>消息头字段表示数据的长度。数据的长度很重要，因为客户端需要知道哪里是应答消息的结束，以及后续应答消息的开始。然而，使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。</p>
<p>如果一个<code>HTTP消息</code>的<code>Transfer-Encoding</code>值为<code>chunked</code>，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p>
<p>其中，每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个<code>CRLF</code>，然后是数据本身，最后块<code>CRLF</code>结束。并且在一些实现中，块大小和CRLF之间填充有白空格<code>(0×20)</code>。</p>
<p>最后一块不再包含任何数据，消息最后以CRLF结尾。在这一个块中的内容是称为<code>footer</code>的内容，是一些附加的<code>Header</code>信息：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">// Chunk编码的格式如下：</span><br><span class="line"></span><br><span class="line">Chunked-Body = *chunk </span><br><span class="line">“<span class="number">0</span>″ <span class="literal">CRLF</span></span><br><span class="line">footer</span><br><span class="line"><span class="literal">CRLF</span></span><br><span class="line">chunk = chunk-size [ chunk-ext ] <span class="literal">CRLF</span></span><br><span class="line">chunk-data <span class="literal">CRLF</span></span><br><span class="line"></span><br><span class="line">hex-no-<span class="literal">zero</span> = &lt;HEX excluding “<span class="number">0</span>″&gt;</span><br><span class="line"></span><br><span class="line">chunk-size = hex-no-<span class="literal">zero</span> *HEX</span><br><span class="line">chunk-ext = *( “;” chunk-ext-name [ <span class="string">"="</span> chunk-ext-<span class="built_in">value</span> ] )</span><br><span class="line">chunk-ext-name = <span class="keyword">token</span></span><br><span class="line">chunk-ext-val = <span class="keyword">token</span> | quoted-<span class="keyword">string</span></span><br><span class="line">chunk-data = chunk-size(OCTET)</span><br><span class="line"></span><br><span class="line">footer = *entity-header</span><br><span class="line"></span><br><span class="line">// 即Chunk编码由四部分组成： </span><br><span class="line">// <span class="number">1.</span>  <span class="number">0</span>至多个chunk块</span><br><span class="line">// <span class="number">2.</span>  <span class="string">'0'</span> <span class="literal">CRLF</span></span><br><span class="line">// <span class="number">3.</span>  footer</span><br><span class="line">// <span class="number">4.</span>  <span class="literal">CRLF</span></span><br><span class="line">// 而每个chunk块由：chunk-size、chunk-ext（可选）、<span class="literal">CRLF</span>、chunk-data、<span class="literal">CRLF</span>组成。</span><br></pre></td></tr></table></figure>
<h3 id="反向代理">反向代理</h3>
<p>我们知道，一个简单的<code>Web</code>服务结构，由客户端（浏览器）、前端页面、后端处理程序组成，而其中前端页面的存储及后端处理程序就是位于<code>Server</code>端的服务器中，用户需要使用这个服务时，由浏览器请求前端页面，渲染之后操作将数据传入到后端进行处理。</p>
<p>但是这样简单的结构容易出现问题，如果请求数量过多，服务器的负担过大，则会导致用户无法以正常的浏览速度和浏览效果来使用这一<code>Web</code>服务，于是便需要加入新的结构来解决这一问题，最简单的方法就是使用一个带有缓存功能的反向代理服务器，用户请求资源时，可以如果反向代理服务器中有的话，可以直接从反向代理服务器的缓存中获得，从而减少了对源站的请求和资源的消耗。下面对其具体进行介绍：</p>
<p>反向代理<code>(Reverse Proxy)</code>方式是指以代理服务器来接受<code>Internet</code>上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给<code>Internet</code>上请求连接的客户端，此时代理服务器对外就表现为一个服务器。(注：以下称反向代理服务器为代理服务器)</p>
<p>代理服务器其实不光是可以提供上述所说的缓存功能，其也可以作为源站的一个保护措施，用以保护真实的<code>server</code>端服务器，这种代理服务器和用于负载均衡的代理服务器区别就在于是否严格在防火墙内运行，以及其支持的安全机制可能有所不同。</p>
<p>下面为代理服务器可以起到的部分作用或功能：</p>
<ul>
<li>可以起到保护网站安全的作用，因为任何来自<code>Internet</code>的请求都必须先经过代理服务器。</li>
<li>通过缓存静态资源，加速<code>Web</code>请求。</li>
<li>实现负载均衡。</li>
</ul>
<p>对于负载均衡功能，<code>Web</code>服务提供者可以在一个组织内使用多个代理服务器来平衡各<code>Web</code>服务器间的网络负载。在此模型中，可以利用代理服务器的高速缓存特性，创建一个用于负载平衡的服务器池。此时,如果<code>Web</code>服务器每天都会接收大量的请求，则可以使用代理服务器分担<code>Web</code>服务器的负载并提高网络访问效率。</p>
<p>对于客户机发往真正服务器的请求，代理服务器起着中间调停者的作用。代理服务器会将所请求的文档存入高速缓存。如果有不止一个代理服务器，<code>DNS</code>可以采用<code>循环复用法</code>选择其<code>IP</code>地址，随机地为请求选择路由。客户机每次都使用同一个<code>URL</code>，但请求所采取的路由每次都可能经过不同的代理服务器。</p>
<p>可以使用多个代理服务器来处理对一个高用量内容服务器的请求，这样做的好处是内容服务器可以处理更高的负载，并且比其独自工作时更有效率。在初始启动期间，代理服务器首次从内容服务器检索文档，此后，对内容服务器的请求数会大大下降。</p>
<p>只有<code>CGI</code>请求和偶发的新请求必须一路直达内容服务器。其余的请求可以由代理服务器进行处理。下面对此进行举例说明:</p>
<p>假定对服务器的请求中有<code>90%</code>都不是<code>CGI</code>请求（这表示它们可以进行高速缓存），而且内容服务器每天都会被命中<code>2百万</code>次。在此情况下，如果连接三个反向代理服务器，且每个代理服务器每天处理<code>2百万</code>次命中，则每天将能够处理大约<code>6百万</code>次命中。请求中有<code>10%</code>达到内容服务器，合计约为每个代理服务器每天<code>200,000</code>次命中，即总数仅为<code>600,000</code>，从而效率显著提高。命中次数可从大约<code>2百万</code>次增加到<code>6百万</code>次，而内容服务器的负载却相应地从<code>2百万</code>次减少到<code>600,000</code>次。实际结果依具体情况而定。</p>
<p><img src="/image/202005_smuggling/3.png" alt=""></p>
<h3 id="CDN">CDN</h3>
<p>内容分发网络<code>(Content Delivery Network)</code>，简称<code>CDN</code>,其目的是使用户可就近取得所需内容，解决<code>Internet</code>网络拥挤的状况，提高用户访问网站的响应速度。</p>
<p>其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，<code>CDN</code>系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。</p>
<p>个人理解，<code>CDN</code>更像是一个分布式的有着大量负载均衡反向代理服务器组成的网络，用户请求资源时，可以直接就近选择一个节点，此时用户客户端-节点-源站实则就是构成了上述所说的用户-反向代理服务器-源站的结构。</p>
<p>这里引用<code>@Esacape Plan</code>在<a href="https://juejin.im/post/6844904190913822727" target="_blank" rel="noopener">博客</a>中所描述的用户A、B通过<code>CDN</code>访问指定资源的流程：</p>
<p>用户 A 第一次访问流程如下图所示：</p>
<p><img src="/image/202005_smuggling/4.png" alt=""></p>
<ul>
<li>第 1 步访问的是加速域名，而不是源站域名。</li>
<li>第 3 步返回<code>CNAME</code>域名。</li>
<li>第 5 步返回<code>CNAME</code>域名对应的<code>IP</code>地址，指向<code>CDN</code>边缘层节点。</li>
<li>第 6 步请求的<code>URL</code>（或者说<code>Referer</code>）仍为<code>js.tt.com/idx.html</code>。</li>
<li>第 7 步请求中心层节点时，会带上第 6 步的<code>URL</code>作为参数。</li>
<li>第 8 步通过查询配置数据得到源站域名，进而向源站发起请求。这里的业务服务器即为<code>CDN</code>的源站。简单起见，省略了从<code>DNS</code>服务器查询 A 记录的过程。</li>
<li>在整个过程中，URL 的域名会变化，但是<code>URL</code>的路径不会变化。</li>
</ul>
<p>用户 A 第二次访问流程如下图：</p>
<p><img src="/image/202005_smuggling/5.png" alt=""></p>
<ul>
<li>由于本地<code>DNS</code>客户端拥有了加速域名的解析缓存，就不需要再查询<code>DNS</code>服务器了。</li>
<li>由于<code>CDN</code>边缘层节点有了对应资源的缓存，就不需要再向上请求资源了。</li>
</ul>
<p>用户 B 第一次访问流程如图所示：</p>
<p><img src="/image/202005_smuggling/6.png" alt=""></p>
<ul>
<li>由于用户 A 和用户 B 地域相差比较远，使用不同的边缘层节点，所以边缘层节点没有对应资源的缓存，需要向中心层节点请求资源。</li>
<li>中心层节点拥有该资源的缓存，所以就不需要回源了。</li>
</ul>
<p>从上述访问过程可以看出，在使用<code>CDN</code>时，用户所发送的资源请求如果在节点中未命中，则<code>CDN</code>节点服务器则会向后端源服务器请求资源，即这里可以理解为<code>CDN</code>节点接收了客户端的请求，处理后转发给了后端源服务器，相同的，反向代理服务器也是如此，那么这里就出现了两个服务器对于客户端请求的两次理解了，那么如果这两次理解存在差异，是否会导致什么问题？</p>
<p>结合前面所说的<code>Pipline/Content-Length/Transfer-Encoding</code>,是否会引起对请求的理解不一致，从而导致安全问题？这其实便是<code>HTTP Smuggling</code>问题的根源所在。</p>
<h3 id="HTTP-Smuggling-原因">HTTP Smuggling 原因</h3>
<p>正如上面所讨论的，对于请求理解的不一致和差异，会导致安全问题，那么这种安全问题会导致什么后果呢？这里引用 @mengchen 师傅对<code>HTTP Smuggling</code>原因的描述：</p>
<blockquote>
<p>当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p>
</blockquote>
<p>看下面这个图可能会理解的清晰一些，在使用<code>Pipline</code>时，如果前置服务器和后端服务器对请求的解析处理不一致，从而导致对请求的划分出现问题，则会导致将一个请求一部分解析为正常请求，剩下一部分可能会被划分到其他请求队列中，就成为了走私的请求：</p>
<p><img src="/image/202005_smuggling/7.png" alt=""></p>
<p>而由上图可以看出，如果可以使得前置服务器和后端服务器对请求长度的理解产生偏差，则会导致走私，那么如何使得对长度理解产生偏差呢？这里就回到了前面所提到的<code>Content-Length</code>和<code>Transfer-Encoding</code>(后文中以<code>CL</code>代替<code>Content-length</code>，以<code>TE</code>代替<code>Transfer-Encoding</code>)，这两种方式都可以用来表示<code>HTTP</code>请求内容的长度。</p>
<p>那么就可以很容易想到，如果这两者同时存在，而前置服务器以<code>CL</code>来分辨长度，后端服务器以<code>TE</code>来划分，则就能引发两个服务器对请求长度理解的差异了。或者干脆这两种只有一种存在，但是存在两个，并且前后端对其理解有歧义，可以通过精心构造从而产生混淆，引发长度理解差异。</p>
<p>事实是，为了避免歧义，在<code>rfc2616#section-4.4</code>中规定当这两个同时出现时，Content-Length 将被忽略：</p>
<blockquote>
<p>3.If a Content-Length header field (section 14.13) is present, its decimal value in OCTETs represents both the entity-length and the transfer-length. The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present). If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.</p>
</blockquote>
<p>但是规范只是规范，而不是必须遵守的铁律，因此并不是所有的<code>Web</code>服务器（中间件）都严格遵循规范来进行设计，部分实现者在实现时因为各种原因有了自己的一些设计，从而导致了<code>HTTP Smuggling</code>的出现，关于这一问题的分类， @mengchen 师傅归纳得非常全面，主要分为以下几种（注：后文出现的<code>CL-TE</code>这种形式，意为两个服务器的优先处理，如<code>CL-TE</code>表示前置服务器优先处理<code>CL</code>,后置服务器优先处理<code>TE</code>）：</p>
<ul>
<li>CL不为0的GET请求</li>
<li>CL-CL</li>
<li>CL-TE</li>
<li>TE-CL</li>
<li>TE-TE</li>
</ul>
<h2 id="原因分类">原因分类</h2>
<p>这里对上述五种产生请求走私的原因进行分析，并给出一些样例，如果感兴趣的可以自己<a href="https://portswigger.net/web-security/request-smuggling/exploiting" target="_blank" rel="noopener">实验理解</a>一下。</p>
<h3 id="CL不为0的GET请求">CL不为0的GET请求</h3>
<p>正如我们熟知的，<code>GET</code>请求一般是没有请求体的，也即<code>CL</code>为 0 ， 但是有的服务器在设计实现时，是可能运行存在请求体的，所以如果前置服务器和后端服务器存在这种对请求体的支持不一致，也是可能导致请求走私的。这一点不光是<code>GET</code>请求，实际上对于所有不携带请求体的<code>HTTP</code>请求都是存在这样的问题的。</p>
<p>比如如果代理服务器支持<code>GET</code>请求带有请求体，后端服务器不支持请求体，则如果客户端给代理服务器发送时，将另一个请求附在第一个请求的请求体中，代理服务器会识别成一个请求，但是后端服务则因为不支持请求体，可能会将其识别为两个请求：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> / HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">Content-Length: 44\r\n</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">GET</span> /<span class="built_in"> secret </span>HTTP/1.1\r\n</span><br><span class="line">Host: example.com\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>这里前置服务器支持请求体，将其解析为一个请求，后端服务器因为不支持，将其解析为两个请求：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">// 第一个</span><br><span class="line">GET / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 44<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"></span><br><span class="line">// 第二个</span><br><span class="line">GET / secret HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<h3 id="CL-CL">CL-CL</h3>
<p>构造一个包含两个<code>Content-Length</code>的包，根据规范（<a href="https://tools.ietf.org/html/rfc7230#section-3.3.3" target="_blank" rel="noopener">RFC7230 3.3.3节</a>）此时应当返回<code>400</code>错误，但如果没有正确遵守规范，且服务器按不同的<code>CL</code>进行处理，这可能会导致HTTP走私。当然，这种场景其实并不多见。</p>
<p>假设有这样一个请求报文，并且前置服务器解析第一个<code>CL</code>,后端服务器解析第二个：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 10<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 9<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">12345<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Get</span><br></pre></td></tr></table></figure>
<p>那么在前置服务器中，对这个请求的理解是正常的，于将上述数据包转发给后端服务器。而后端服务器根据第二个<code>CL</code>处理，于是读取到的报文如下：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 10<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 9<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">12345<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>此时，后端服务器认为自己已经读取完，并且也生成了对应的响应发送，但是可以看到由前置服务器带来的字符中还剩下一个<code>Get</code>，那么这个字符就有可能作为下一个请求的一部分，假设现在有一个正常的用户发起了一个请求:</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>那么后端服务器会将前一个请求中剩下的<code>Get</code>作为后一个请求的一部分，也就是变成了这样：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">GetGET /index.html HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>可以看到，此时已经对正常用户的请求产生了影响了，此时后端处理这个用户的请求时就会发现，这个请求中使用的<code>HTTP Method</code>为<code>GetGET</code>，很显然，会给客户端返回一个<code>request method not found</code>。</p>
<p>这里这种场景的话，只是导致请求失败，那么如果能够结合<code>CRLF</code>的话，可能就能进行危害更大的攻击了。</p>
<h3 id="CL-TE">CL-TE</h3>
<p>在这种情况中，前置服务器认为<code>Content-Length</code>优先级更高（或者根本就不支持<code>Transfer-Encoding</code>） ，后端认为<code>Transfer-Encoding</code>优先级更高。因此在发送同时带有<code>CL</code>和<code>TE</code>的请求时，可能会导致请求走私。而这种情况，其实也就是在前几天的<code>defcon ctf qual</code>中出现的。</p>
<p>比如下面这个例子：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 8<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Transfer-Encoding: chunked<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Get</span><br></pre></td></tr></table></figure>
<p>在前置服务器处理时，使用<code>CL</code>进行处理，即得到一个完整的请求体：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Get</span><br></pre></td></tr></table></figure>
<p>这时是正常的，但是转发给后端服务器时，后端服务器根据<code>TE</code>来进行处理，则当其读取到<code>\r\n\r\n</code>时，会认为当前请求体已经读取完成，即读取到的请求体如下：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>和<code>CL-CL</code>中一样，此时后端服务器处理完成后完成响应，而剩下的<code>Get</code>将会被走私到下一个请求中，下一个请求就变成了这样：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">GetGET /index.html HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<h3 id="TE-CL">TE-CL</h3>
<p>和上一种情况类似，但是此时前置服务器认为<code>Transfer-Encoding</code>优先级更高，后端认为<code>Content-Length</code>优先级更高（或者不支持<code>Transfer-Encoding</code>）。如以下报文：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 4<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Transfer-Encoding: chunked<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">12<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，前置服务器使用<code>TE</code>进行处理，即使用<code>\r\n\r\n</code>作为结束标识，所以可以将这个报文全部读取，而在后端服务器中，使用<code>CL</code>进行处理，此时该值为<code>4</code>,则后端解析的请求体为：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">12<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>至于剩下的内容，则会被后端服务器解析到另一个请求中：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<h3 id="TE-TE">TE-TE</h3>
<p>上述已经说了<code>CL-CL</code>的情况，那如果前置和后端服务器都优先支持<code>Transfer-Encoding</code>，是否可以进行请求走私呢？</p>
<p>答案显然是可以的，这里我们可以对服务器的实现进行分析和FUZZ，恶意构造出使其中一个服务器不优先支持<code>TE</code>的请求（或者无法识别到<code>TE</code>），从而使其转而使用<code>CL</code>进行解析处理。这里如果是使前置服务器产生混淆，则就变成了另外一种形式的<code>CL-TE</code>，类似的，使后端服务器混淆则变成了另一种形式的<code>TE-CL</code>。</p>
<p>那么如何导致这种混淆呢？这里一种比较简单的方法是使用大小写，如果前置服务器和后端服务器在解析<code>TE</code>的时候对大小写敏感，则可能会导致这样的情况，或者使用一个不符合规范的<code>TE</code>头，使得其中一个服务器解析失败，转而使用<code>CL</code>。</p>
<p>下面为一个样例，需要注意的是，因为产生混淆后需要让服务器以<code>CL</code>进行处理，所以这里是使用了一个<code>CL</code>,两个<code>TE</code>,下面这个样例通过混淆将<code>TE-TE</code>转为了<code>TE-CL</code>：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Host: example.com<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-length: 4<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Transfer-Encoding: chunked<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Transfer-encoding: cow<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">5c<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">GetPOST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 15<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">x=1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>对于上述请求，可以看到前后的<code>Transfer-Encoding</code>，E的大小写不同，并且后一个<code>TE</code>中使用<code>cow</code>，因此可能导致识别的不同。前置服务器使用正常的<code>TE</code>进行解析，因此得到的请求体为完整的，而后端服务器因为对<code>TE</code>解析失败，因此使用<code>CL</code>进行解析，则只能解析到下面的请求体：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">5c<span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<p>而后续其他的内容则会当做是下一个请求的内容：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">GetPOST / HTTP/1.1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">Content-Length: 15<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">x=1<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line">0<span class="symbol">\r</span><span class="symbol">\n</span></span><br><span class="line"><span class="symbol">\r</span><span class="symbol">\n</span></span><br></pre></td></tr></table></figure>
<h2 id="利用与防御">利用与防御</h2>
<p>关于上述所说的一些场景，<a href="https://portswigger.net/web-security/request-smuggling/exploiting" target="_blank" rel="noopener">PortSwigger</a>中有一些具体的实验，可以进行尝试从而加深理解，而在现实应用中，请求走私攻击又可能会导致怎么样的后果呢？</p>
<p>有一个现成的例子就是在<code>Defcon CTF 2020 Qual</code>中的<code>uploooadit</code>一题，有兴趣的可以<a href="https://www.xiaozzz.xyz/2020/05/22/Defcon-CTF-Qual-2020-Web-WP/#uploooadit">尝试复现</a>。另外，<code>PortSwigger</code>也对其现实危害进行了归纳：</p>
<ul>
<li>绕过前置服务器的安全限制</li>
<li>获取前置服务器修改过的请求字段</li>
<li>获取其他用户的请求</li>
<li>反射型<code>XSS</code>组合拳</li>
<li>将<code>on-site</code>重定向变为开放式重定向</li>
<li>缓存投毒</li>
<li>缓存欺骗</li>
</ul>
<p>一样的，结合<code>PortSwigger</code>给出的实验会更容易理解，另外，如果不满足于这些的话，可以搭建一下<code>CVE-2018-8004</code>的环境进行<a href="https://paper.seebug.org/1048/#4-httpcve-2018-8004" target="_blank" rel="noopener">复现</a>。</p>
<p>而对于请求走私如何防御呢？</p>
<blockquote>
<p>不针对特定的服务器，通用的防御措施大概有三种：</p>
<ul>
<li>禁用代理服务器与后端服务器之间的TCP连接重用。</li>
<li>使用HTTP/2协议。</li>
<li>前后端使用相同的服务器。</li>
</ul>
</blockquote>
<p>其实，归根到底的话，这些防御措施都是在已有这样的问题的情况下如何进行防御，在条件允许的情况下，如果能够严格遵循<code>RFC</code>中的规范来设计实现服务器的话，想必可以最大程度上减少此类问题的发生。当然，这一点可能又会因为各种其他因素而变得并不容易。</p>
<h2 id="总结">总结</h2>
<p>其实<code>HTTP Smuggling</code>并不是最近才兴起的，而是一个长久以来都存在的问题，这种因为处理的不一致性而导致的问题很多，其中不光是有请求走私这种，另外还有可能可以利用不一致性绕过<code>Web</code>应用中的<code>check</code>，或者引发其他问题，比如之前所接触的同组学长发现的利用<code>CDN</code>和源站对<code>Range</code>头的解析差异而导致可以<a href="https://ieeexplore.ieee.org/document/9153355/" target="_blank" rel="noopener">使用CDN进行Dos攻击</a>。</p>
<p>总得来说，互联网野草般的发展，决定了总体环境的多样化与多元化，而开发者设计和实现的不一致，也可能会导致很多问题。规范的制定在一定程度上避免了这样的问题发生，但是总归系统的实现者是一个独立的灵魂和个体，不同的机构和组织也会有自己的一些考虑，从而在规范的遵循上会有差异，这类问题往往也是无法避免的，而作为一个安全研究者，如果能够发掘一些这样的问题，从而减少一些由此带来的危害，相比会是件很意思也很有意义的事。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></li>
<li><a href="https://www.cnblogs.com/PixelOrange/p/13445275.html" target="_blank" rel="noopener">HTTP走私攻击详解</a></li>
<li><a href="https://xz.aliyun.com/t/7501" target="_blank" rel="noopener">浅谈HTTP请求走私</a></li>
<li><a href="https://portswigger.net/web-security/request-smuggling/exploiting" target="_blank" rel="noopener">PortSwigger Lab</a></li>
<li><a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener">RFC 7230</a></li>
<li><a href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank" rel="noopener">RFC 2616</a></li>
<li><a href="https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf" target="_blank" rel="noopener">HTTP Response Splitting</a></li>
<li><a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener">HTTP Request Smuggling</a></li>
<li><a href="https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf%5D" target="_blank" rel="noopener">HTTP Desync Attacks: Smashing into the Cell Next Door</a></li>
</ul>
</div><div class="tags"><a href="/tags/Web%E6%BC%8F%E6%B4%9E/">Web漏洞</a><a href="/tags/CTF/">CTF</a></div><div class="post-nav"><a class="pre" href="/2020/08/28/%E9%A6%96%E5%B1%8A%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF%E9%83%A8%E5%88%86wp/">首届钓鱼城杯部分wp</a><a class="next" href="/2020/05/22/Defcon-CTF-Qual-2020-Web-WP/">Defcon_CTF_Qual_2020-Web-WP</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://www.xiaozzz.xyz/2020/05/26/HTTP-Smuggling-请求走私/';
    this.page.identifier = '2020/05/26/HTTP-Smuggling-请求走私/';
    this.page.title = 'HTTP_Smuggling-请求走私';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//xiaoZz.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//xiaoZz.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://xiaoZz.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF-writeup/">CTF_writeup</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/">Web漏洞介绍</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A0%81%E4%B8%8E%E5%BC%80%E5%8F%91/">编码与开发</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Web%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">Web漏洞</a> <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 15px;">反序列化</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 15px;">密码学</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA/" style="font-size: 15px;">网络安全理论</a> <a href="/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/" style="font-size: 15px;">哈希函数</a> <a href="/tags/SSRF/" style="font-size: 15px;">SSRF</a> <a href="/tags/writeup/" style="font-size: 15px;">writeup</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" style="font-size: 15px;">字符串操作</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 15px;">开发</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/28/%E9%A6%96%E5%B1%8A%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF%E9%83%A8%E5%88%86wp/">首届钓鱼城杯部分wp</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/26/HTTP-Smuggling-%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/">HTTP_Smuggling-请求走私</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/22/Defcon-CTF-Qual-2020-Web-WP/">Defcon_CTF_Qual_2020-Web-WP</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/13/%E7%BD%91%E9%BC%8E%E6%9D%AF2020-%E9%9D%92%E9%BE%99%E7%BB%84-%E9%83%A8%E5%88%86WP/">网鼎杯2020-青龙组-部分WP</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0-%E5%AF%86%E7%A0%81%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8/">密码学学习-密码硬件安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/25/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/">密码学学习-分组密码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/20/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0-MAC%E4%B8%8EAEAD/">密码学学习-MAC与AEAD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/">正则表达式基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/16/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%B8%8EPKI/">密码学学习-数字证书与PKI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AD%A6%E4%B9%A0-%E5%AF%86%E7%A0%81%E6%9D%82%E5%87%91%E5%87%BD%E6%95%B0/">密码学学习-密码杂凑函数</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//xiaoZz.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://momomoxiaoxi.com/" title="moxiaoxi" target="_blank">moxiaoxi</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">xiaoZ's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="100,100,100" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>